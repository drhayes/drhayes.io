import { Metadata, whichDate } from '$lib/metadataUtil';

import allPages from '../lib/allPages';
import RSS from 'rss';

export async function get({ host }) {
  const pages: Metadata[] = await allPages();

  const feed = new RSS({
    title: 'drhayes.io',
    description: 'All the pages from drhayes.io',
    site_url: 'https://drhayes.io',
    feed_url: 'https://drhayes.io/feed.xml',
    image_url: 'https://drhayes.io/img/raven.png',
    copyright: 'This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License by David R. Hayes.',
    pubDate: new Date().toISOString(),
  });

  pages.forEach(page => {
    feed.item({
      title: page.title,
      url: `https://drhayes.io${page.slug}`,
      date: whichDate(page),
      description: page.description,
      author: 'David Hayes <hi@drhayes.io>',
      categories: page.tags || [],
    });
  });

  return {
    headers: {
      'Cache-Control': 'public, max-age=0, must-revalidate',
      'Content-Type': 'application/xml'
    },
    body: feed.xml({ indent: true }),
  };
}

/**<feed xmlns="http://www.w3.org/2005/Atom">
<title>drhayes.io</title>
<subtitle>The personal site of David Hayes.</subtitle>
<link href="https://drhayes.io/feed.xml" rel="self"/>
<link href="https://drhayes.io"/>
<updated>2021-03-14T00:00:00-00:00</updated>
<id>https://drhayes.io/</id>
<author>
<name>David Hayes</name>
<email>hi@drhayes.io</email>
</author>
<entry>
<title>A New Start! ðŸ™€</title>
<link href="https://drhayes.io/blog/new-blog-start/"/>
<updated>2018-09-12T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/new-blog-start/</id>
<content type="html"><p>It appears I'm gonna start blogging again.</p> <p>While developing my <em>Big Game</em> (which will get its own reveal very soon now), I kept coming across problems that were not addressed in any tutorials that I could find. I have tons of game development books, I've read lots of articles, and there's a real dearth of content beyond the beginner but before the expert.</p> <p>So I thought I should reconfigure my site not just for the content related to the game directly, like where to buy it, but also to post about its development -- problems I've encountered and their solutions (or workarounds!), interesting tricks, great tools. All of it.</p> <p>Along the way I finally bit the bullet and switched to Jekyll. I don't know what I had against it before but it's a great static-site generator. Before this I tried <a href="https://gohugo.io/">Hugo</a>, <a href="https://gatsbyjs.org/">GatsbyJS</a>, and <a href="https://metalsmith.io/">Metalsmith</a>. Each one had their shortcomings and I always felt like I was fighting to do things I wanted. Not so with Jekyll. I've fought hard to catch up to everyone else, but I'm finally here! Yay!</p> <p>Watch this space.</p></content>
</entry>
<entry>
<title>Announcing Gemini Rising, my new game</title>
<link href="https://drhayes.io/blog/new-game-gemini-rising/"/>
<updated>2018-09-13T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/new-game-gemini-rising/</id>
<content type="html"><p>The name of the <em>Big Game</em> that I've been working on for forever is "<a href="https://drhayes.io/games/gemini-rising">Gemini Rising</a>".</p> <p><a href="https://drhayes.io/games/gemini-rising">Here's the game's home page</a>.</p> <p>I will be documenting the process here on my site. Beyond blog posts with updates about my progress, I also plan on writing longer-form articles about problems I encountered and the solutions I've come up with to those problems. Hopefully, if other people have similar problems my solutions and failures along the way will help them.</p> <p>Here are some topics I've got planned:</p> <ul> <li><strong>AI</strong>: behavior trees and GOAP.</li> <li><strong>Navmeshes</strong>: platforming and flight.</li> <li><strong>Procedural level generation</strong>: pros and cons</li> </ul> <p>As of today, the game has around 15k lines of code in it:</p> <pre><code class="hljs language-bash">[~/games/gr (master) âš¡] âž” find . -name <span class="hljs-string">"*.lua"</span> -not -path <span class="hljs-string">"./lib/*"</span> -not -path <span class="hljs-string">"./media/levels/*"</span> | xargs wc -l | sort | tail 260 ./core/crafting.lua 261 ./procgen/chunkTilemap.lua 264 ./systems/cameraSystem.lua 287 ./systems/playerMoveSystem.lua 376 ./systems/mapSystem.lua 431 ./states/manageInventory/chassisScreen.lua 470 ./states/manageInventory/loadoutsScreen.lua 521 ./core/inventory.lua 669 ./core/ui.lua 14852 total</code></pre> <p>That's startling to me given what the game can and cannot do at this point. This project is officially the largest single thing I've ever written and I don't think I can call myself a dilettante game programmer. So, yay?</p></content>
</entry>
<entry>
<title>Gemini Rising: The Stats</title>
<link href="https://drhayes.io/blog/gemini-rising-stats/"/>
<updated>2018-09-14T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/gemini-rising-stats/</id>
<content type="html"><p>I thought it'd be interesting to include stats about the game as I develop it.</p> <p>Gemini Rising has 14,852 lines of Lua in it excluding libraries and generated files. As a friend of mine put it, that's "profit", not "revenue" -- I've written and re-written lots of the game up to now. Hopefully I'm done doing large scale rewrites. Hopefully. Sure.</p> <p>The longest module in the project is <code>ui.lua</code> at 669 lines, the immediate-mode keyboard/gamepad accessible UI library I wrote for the game. Every other UI library I could find relied on using the mouse, which wasn't going to work for me. I think it might make a good library someday.</p> <p>So far I've got 736k of raw assets that turns into 2.5M of data once processed by my build. I can build the entire game with one step, <code>make start</code>. I suspect I'm entering the "content" phase of my game, where the amount of stuff that I put into it exceeds the amount of work I do on the systems underlying it, but we'll see.</p> <p>I'm using <a href="https://github.com/Tjakka5/Concord">Concord</a>, which is an <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system">entity-component-system</a> framework. As of today, I've got 33 separate systems managing entities using up to 42 components. I'm not done making types of entities, or types of maps, otherwise I'd write about that.</p> <p>I'm planning on writing more articles going into detail about my components and systems in the future.</p></content>
</entry>
<entry>
<title>Oh Well, Gatsby It Is</title>
<link href="https://drhayes.io/blog/oh-well-gatsby-it-is/"/>
<updated>2018-11-24T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/oh-well-gatsby-it-is/</id>
<content type="html"><p>I switched over to Gatsby because Ruby is kind of annoying and because I'm more of a JavaScript tinkerer than a Ruby "it just works leave it alone"-er.</p> <p>I also switched the site publishing process from Netlify to a <a href="https://circleci.com/">CircleCI</a> configuration that publishes directly to an S3 bucket via the <a href="https://aws.amazon.com/tools/">AWS SDK</a>. I just can't leave well enough alone, I guess.</p></content>
</entry>
<entry>
<title>Ha Ha, Just Kidding, I'm Using NextJS Now</title>
<link href="https://drhayes.io/blog/ha-ha-just-kidding-nextjs/"/>
<updated>2018-12-06T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/ha-ha-just-kidding-nextjs/</id>
<content type="html"><p>Just when I thought I was done tinkering with my site I found <a href="https://nextjs.org/">NextJS</a>. Oops.</p> <p>I mean, I don't need an excuse to tinker with things that are better left alone. I apparently derive great joy from experimenting with static-site-generators including <a href="https://gohugo.io/">hugo</a> and <a href="https://gatsbyjs.org/">gatsby</a> and <a href="https://metalsmith.io/">metalsmith</a>. Before that, I had a lot of fun playing around with seemingly every open source PHP-based CMS in existence. My bookshelf is full of blank books that have one page written in them before I moved on to something else because the current notebooks just weren't good enough for some reason. I re-arrange my office once a year or so. Just to put all this in context.</p> <p>But I think <a href="https://nextjs.org/">NextJS</a> is the way for me to go now primarily because it sits at the crossroads of three things I like very much right now: JavaScript, Markdown, and no servers.</p> <p>I'm not going to claim JavaScript is a perfect language, but I'm using it a lot these days so it's very comfortable for me. Markdown is hands-down my favorite long-form writing data format. And not having servers is the way of the future. Because my site is hosted on <a href="https://firebase.google.com/">Firebase</a>, I don't have to worry about my site being unavailable due to a scarcity of CPU resources or money resources (since static hosting is very cheap).</p> <p>Enter <a href="https://nextjs.org/">NextJS</a>.</p> <p>I believe my site is at the point where I can simply write into various Markdown files and have what I expect show up where I expect it now.</p> <p>And if I need more custom functionality it's only a few JS lines away from working across my entire site.</p> <p>Also! Because I'm using <a href="https://firebase.google.com/">Firebase</a> hosting, I have access to some Firebase features that will be fun to play with. Especially <a href="https://firebase.google.com/docs/functions/">Cloud Functions</a>.</p></content>
</entry>
<entry>
<title>Ha Ha Again, It's Hugo</title>
<link href="https://drhayes.io/blog/ha-ha-again-its-hugo/"/>
<updated>2018-12-13T05:25:53-00:00</updated>
<id>https://drhayes.io/blog/ha-ha-again-its-hugo/</id>
<content type="html"><p>I shouldn't be left alone with static site generators.</p> <p>Seduced by Hugo's speed and an itch to learn the Go templating language! An excuse to learn <a href="https://tachyons.io/">Tachyons</a>! Why the hell not!</p> <p>Truthfully, my <a href="https://github.com/drhayes/drhayes.io/tree/23d27e32f6b8ca02b08651020c0e83e64478653d">NextJS</a> solution had two glaring flaws:</p> <ol> <li>I'd written most of it. I'm a big fan of code I didn't write.</li> <li>It didn't refresh automatically when I saved my posts.</li> </ol> <p>Because of how I'd written my <a href="https://github.com/drhayes/drhayes.io/blob/23d27e32f6b8ca02b08651020c0e83e64478653d/next.config.js"><code>next.config.js</code></a> it didn't re-generate the site when I saved posts. It was the tiniest thing, I didn't even notice it as I was changing all the React components around to make my previous site. But once I got to writing that last post and noticed... it's like a tiny rock fell in my shoe. And then the rock grew in size until I sat down and re-read a bunch of Hugo documentation.</p> <p>There has to be some trick to get Next to watch the <code>content</code> directory. I couldn't find it, though. And I was <em>basically</em> re-writing a system similar to Hugo's, with a <code>content</code> directory and automatically generating tag pages. Once that realization struck me I knew I was doomed -- I was gonna convert the site back to Hugo. Ugh.</p> <p>All that stuff I said in the last post is still true, though. A part of me worries that there will be some bit of customization to the site that I won't be able to accomplish in Hugo. That's the only "requirement" that I had for my site. However, I also don't believe in engineering for things that haven't happened yet, so here we are.</p> <p>Yet, also truthfully, I like messing around with this stuff. Coder's gonna code. And my personal site has to be frictionless and exactly the way I want it to work.</p> <p><img src="https://drhayes.io/img/ha_ha_guy.jpg" alt="Ha Ha, The Internet"></p></content>
</entry>
<entry>
<title>Gemini Rising AI - Introduction</title>
<link href="https://drhayes.io/blog/gemini-rising-ai-intro/"/>
<updated>2019-03-21T21:10:51-00:00</updated>
<id>https://drhayes.io/blog/gemini-rising-ai-intro/</id>
<content type="html"><p>When I went looking for articles about game AI that went beyond the most basic level I had a hard time finding any. Most articles were more interested in defining one basic concept and providing an easy, "Hello World" example than diving deep into solving real problems in a real game.</p> <p>I'd like to change that for future programmers like me looking for guidance.</p> <p>I'm going to write a series of posts about my experiences crafting the AI for my game, <a href="https://drhayes.io/games/gemini-rising">Gemini Rising</a>. Since I was learning as I go I'm sure there are going to be mistakes; I'd love to hear about them!</p> <p>UPDATED 2020-07-13: Added 'game-ai' tag.</p> <h2>Overview</h2> <p>Here are the solutions I tried, in roughly chronological order:</p> <ul> <li>Lua scripting with coroutines</li> <li>Behavior trees</li> <li>Goal-oriented action planning</li> <li>Behavior trees (but better this time)</li> </ul> <h2>Goals</h2> <p>My goals shifted over time, but here is the list in priority order:</p> <ul> <li><strong>Fun experience for the player</strong>. Above all else, the game had to be fun for the player.</li> <li><strong>Learn something about game AI</strong>. In all my wandering, I wanted to learn more about making good AI for games.</li> <li><strong>Be easy for me</strong>. I'm jealous of my time as a hobbyist gamedev, so anything that required too much brainpower to adapt, use, modify, or fix was right out. I didn't need visual designers, but if I couldn't fix AI problems relatively easily then this wasn't the method for me.</li> <li><strong>Be predictable</strong>. This one was added later; I'll talk about it more when it becomes important.</li> </ul> <h2>The Posts</h2> <p>Here are the posts that are ready.</p> <ol> <li><a href="https://drhayes.io/blog/gemini-rising-ai-lua-scripting/">Lua Scripting</a></li> <li><a href="https://drhayes.io/blog/gemini-rising-ai-behavior-trees/">Behavior Trees</a></li> <li><a href="https://drhayes.io/blog/gemini-rising-ai-goap/">Goal-Oriented Action Planning</a></li> </ol></content>
</entry>
<entry>
<title>Gemini Rising AI - Lua Scripting</title>
<link href="https://drhayes.io/blog/gemini-rising-ai-lua-scripting/"/>
<updated>2019-03-22T16:10:26-00:00</updated>
<id>https://drhayes.io/blog/gemini-rising-ai-lua-scripting/</id>
<content type="html"><p>This post is the first in <a href="https://drhayes.io/2019/03/21/gemini-rising-ai-introduction/">a series I'm writing about scripting the AI in my game</a>, <a href="https://drhayes.io/games/gemini-rising">Gemini Rising</a>. This one covers scripting with <code>setfenv</code> and Lua coroutines.</p> <p>UPDATED 2020-07-13: Added 'game-ai' tag.</p> <h2>Intro</h2> <p>When I started this game I'd never programmed seriously in Lua before. I'd purchased the Lua book a long time ago, read it once, then never had a chance to use the language again.</p> <p>Until I fell in <a href="https://love2d.org/">LÃ¶ve</a>.</p> <p>So I set about hoovering up as much Lua content as I could. I was excited to dig into what seemed from the outside to be <em>the</em> gamedev scripting language.</p> <p>The first decision I made regarding my game AI was what technology to use. I decided that I would use a scripting language. The first language I considered was...well, Lua. Since I was already using a scripting language I didn't see the point in introducing another complexity into my hobby project.</p> <h3>Coroutines</h3> <p>I'm not going to talk about what a coroutine is. There are <a href="https://en.wikipedia.org/wiki/Coroutine">great references for coroutines</a> out there.</p> <p>Suffice to say, the canonical example for using coroutines is for AI in video games. This models well inside the code since a video game could be said to be a cooperative multitasking endeavor. I figured I was on firm ground.</p> <h3><code>setfenv</code></h3> <p>LÃ¶ve uses Lua 5.1, which means I have access to <code>setfenv</code>. It lets you isolate the environment that your function runs in. It's been removed from later versions of the language. That is what we in the writing business call "foreshadowing".</p> <p>Here are the <a href="https://www.lua.org/pil/14.3.html">docs for <code>setfenv</code></a>.</p> <h2>Scripting with <code>setfenv</code></h2> <p>I had some vague notion of organizing my game as a series of plugins. At this point, every entity in my game was an object that lived in an array of <code>entities</code> somewhere in the <code>game</code> global object. I felt like I needed some kind of overall architecture, even at this early phase. I find hard API boundaries impose rigor on my coding and make sure I don't make too many hacky messes off in the dark corners of a codebase.</p> <p>In the name of not making hacky messes, I thought that my initial AI scripts shouldn't have access to the entire game. I thought that I needed some kind of isolation. And, since I was programming in Lua, I thought I'd explore its features and use things I hadn't used in other languages before.</p> <p>Enter <code>setfenv</code>.</p> <p>Wiser heads than mine warned me not to do this. I thought I'd be fine. I was wrong.</p> <h3>The <code>Brain</code></h3> <p>The version I was working with is here: <a href="https://gist.github.com/drhayes/340fbc7f967b35dbc462efd5f187619d">https://gist.github.com/drhayes/340fbc7f967b35dbc462efd5f187619d</a></p> <p>The basic idea is that the game AI will look relatively straightforward, lots of "make decision about how to do this" followed by "wait for it to finish".</p> <p>The scripts would be loaded from disk and passed to the <code>Brain.create</code> function. More on that janky-looking <code>loadString(string.dump(f))</code> business below.</p> <p>I thought to myself, <em>How great this'll be! I can write the game AI as normal Lua programs without having to muck around with all those weird data structures that are in state machines and stuff.</em></p> <p>Here's what that looked like in practice:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env)</span></span> <span class="hljs-keyword">local</span> sprite, player, lume, flux, waitSeconds = env.target, env.player, env.lume, env.flux, env.waitSeconds <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span> sprite.animations:play(<span class="hljs-string">'idle'</span>) <span class="hljs-keyword">if</span> game.entities.player <span class="hljs-keyword">then</span> <span class="hljs-keyword">local</span> player = game.entities.player <span class="hljs-keyword">local</span> distance = lume.distance(sprite.x, sprite.y, player.x, player.y) <span class="hljs-keyword">local</span> sign = lume.sign(player.x - sprite.x) <span class="hljs-keyword">if</span> sprite.y &#x3C; player.y <span class="hljs-keyword">and</span> distance &#x3C; <span class="hljs-number">200</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">-- Swoop!</span> sprite.animations:play(<span class="hljs-string">'soar'</span>) sprite.animations.flipX = sign == <span class="hljs-number">-1</span> <span class="hljs-keyword">local</span> midX = sprite.x + (sign * <span class="hljs-number">100</span>) <span class="hljs-keyword">local</span> endX = midX + (sign * <span class="hljs-number">100</span>) <span class="hljs-keyword">local</span> oy = sprite.y flux.to(sprite, <span class="hljs-number">1</span>, { x = midX }):ease(<span class="hljs-string">'linear'</span>) :oncomplete(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> flux.to(sprite, <span class="hljs-number">1</span>, { x = endX }):ease(<span class="hljs-string">'linear'</span>) <span class="hljs-keyword">end</span>) flux.to(sprite, <span class="hljs-number">1</span>, { y = player.y - player.height / <span class="hljs-number">5</span> }) :ease(<span class="hljs-string">'cubicout'</span>) :oncomplete(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> flux.to(sprite, <span class="hljs-number">1</span>, { y = oy }) :ease(<span class="hljs-string">'cubicin'</span>) :oncomplete(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> sprite.animations:play(<span class="hljs-string">'idle'</span>) <span class="hljs-keyword">end</span>) <span class="hljs-keyword">end</span>) waitSeconds(<span class="hljs-number">4</span>) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> waitSeconds(<span class="hljs-number">1</span>) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre> <p>Turns out it doesn't go so well.</p> <p>Looking at this code now makes me cringe. There are so many lessons to be learned here that I hadn't learned yet. I was so busy trying to get the animations and pathing to work that I wasn't handling cases like <em>Did I just get shot and need to play my hurt animation?</em> and <em>Am I actually dead?</em>.</p> <p>I thought what I wanted was imperative, synchronous-looking code for my AI routines. I thought writing the AI for this game would be simpler that way. But it's not; I don't think an imperative solution to my event-based problem was going to work.</p> <p>I wanted my game entities to be responsive to outside stimuli, which meant that after every <code>wait*</code> call I'd have to check if the sprite was dead. Or, if it died during the <code>wait*</code> calls I'd have to... what, exactly? I never figured it out with this method because I knew the end-result would be a tangled mess of repetition and a bad representation of what I really wanted the entities to do.</p> <p>Imagine after every wait a multi-line <code>if</code> statement about what to do if my entity had died. Or what to set the animation to if it had been hurt during one of those <code>wait</code>s. Now repeat it after every wait. For this simple example it's not so bad. For something with more complex behavior such as a patrolling guard that chases you from platform to platform before giving up and returning to trigger an alarm panel it could get truly gross.</p> <p>On top of that, the <code>Brain</code>s are doing too much. This code is not only making decisions in response to what the player is doing, it is also managing the animations, playing sounds, adjusting physics. If I have multiple strategies for each enemy type (one that patrols, one that stands guard, one that investigates noises) then each one of those <code>Brain</code>s will have to duplicate the logic of how to handle the animations, sound, and physics.</p> <p>By interleaving all those game system decisions with the entity-level decisions, I was obscuring the unique value of the brain as well, making it less self-documenting. I would argue that the most important line out of that prior script is this one:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">if</span> sprite.y &#x3C; player.y <span class="hljs-keyword">and</span> distance &#x3C; <span class="hljs-number">200</span> <span class="hljs-keyword">then</span></code></pre> <p>Every other line in that script obscures the true <em>behavior</em> of this entity's brain: if the player is below me and less than 200 distance away, swoop down and get them.</p> <p>But those are just stylistic problems. I haven't gotten to the big bug yet.</p> <h3>In Which I Make Things Too Complicated</h3> <p>Remember how I said I wanted a plugin architecture for my game? At this point, the code for the entities' AI were stored as Lua scripts somewhat separate from the codebase. Instead of getting <code>require</code>d in, they would be read from the filesystem and handed to the <code>Brain</code> when needed. This seemed like a fantastic idea at the time; I could customize what brain an entity had in the tilemap editor by writing its name as a string!</p> <p>But, remember how I'd just started programming in Lua? I'd missed some subtleties with my approach.</p> <p>I was loading the text of the functions from disk, then passing them directly to <code>coroutine.create</code>. That means that each function was only loaded once, even if multiple entities used them. That means that, if I loaded seven Beetles in a row that I would be modifying <strong>the same function</strong> with <code>setfenv</code>. Oh yeah.</p> <p>It took me a while to figure out why all my enemies of one type were sort of moving in sync. Very pernicious.</p> <p>My brilliant solution to this was this code:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Brain.create</span><span class="hljs-params">(f, sprite)</span></span> <span class="hljs-keyword">local</span> f_clone = <span class="hljs-built_in">loadstring</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">dump</span>(f)) <span class="hljs-built_in">setfenv</span>(f_clone, { sprite = sprite, waitSeconds = waitSeconds, waitForAnimation = waitForAnimation, <span class="hljs-comment">-- Useful globals...</span> game = sprite.game, <span class="hljs-built_in">print</span> = <span class="hljs-built_in">print</span>, inspect = inspect, <span class="hljs-built_in">math</span> = <span class="hljs-built_in">math</span>, lume = lume }) <span class="hljs-keyword">local</span> co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(f_clone) <span class="hljs-keyword">local</span> okay, msg = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> okay <span class="hljs-keyword">then</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">'Error in Brain.create'</span>, msg) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre> <p>Note to any programmers out there: if the solution to your problem is to dump the function as a string and then, basically, <code>eval</code> it back into your environment... you might be on the wrong path.</p> <p>When I touched on the possible code duplication in the last section, one could argue that the common behaviors for any particular <code>Brain</code> could be refactored out into a common script that was then included in every <code>Brain</code> that needed it. But, with <code>setfenv</code>, how would I do that? I'd have to pass the "common" scripts into the environment that I was passing into my script. That "common" script area now becomes a kind of kitchen sink of code that applies to several different <code>Brain</code>s, an organizational mess -- all to solve a problem I'm imposing on myself because I was fascinated with isolating the scripts' environments. Not a good move.</p> <p>If I were truly interested in making my game use a plugin architecture then I would revisit these issues. <code>setfenv</code> is not to blame here; <em>I</em> am, for cursing the limitations of a tool that solves a problem that I created myself. Once I unpacked all of that, I abandoned this approach.</p> <h2>Finale</h2> <p>I don't want to throw the baby out with the bathwater. Coroutines are very useful constructs. There are parts of my game today that still use them for straightforward timing that doesn't need to react to any outside events. I coordinate my coroutines these days using the excellent <a href="https://github.com/airstruck/knife/blob/master/readme/convoke.md">knife.convoke</a> library.</p> <p>Coroutines for my game AI, though, are the wrong approach. They are iterative where I need something more event-based. My initial foray, at least, wasn't modular enough to get me a lot of bang for my buck.</p> <p><code>setfenv</code> is not a solution to a problem I have. Simple as that.</p> <p>In hindsight, some of these were newbie Lua programmer mistakes. I also hadn't settled on a larger architecture for my game yet, so there were lots of encapsulation violations flying around in my codebase that I knew I'd have to fix later.</p> <p>The <a href="https://drhayes.io/2019/03/22/gemini-rising-ai-behavior-trees/">next post</a> will cover my initial adventure into behavior trees.</p></content>
</entry>
<entry>
<title>Gemini Rising AI - Behavior Trees</title>
<link href="https://drhayes.io/blog/gemini-rising-ai-behavior-trees/"/>
<updated>2019-03-22T16:12:57-00:00</updated>
<id>https://drhayes.io/blog/gemini-rising-ai-behavior-trees/</id>
<content type="html"><p>This post is the second in a <a href="https://drhayes.io/blog/gemini-rising-ai-introduction/">series I'm writing about scripting the AI in my game, Gemini Rising</a>. This one is about behavior trees.</p> <p>There aren't enough resources out there that dive deeply into interesting programming topics. It's easy to find "hello world" examples, but it's harder to find meaty essays that discuss pros and cons, tradeoffs taken, long-term consequences unforeseen. These posts are my attempt to fix that.</p> <p>UPDATED 2020-07-13: Added 'game-ai' tag.</p> <h2>Intro</h2> <p>After <a href="https://drhayes.io/blog/gemini-rising-ai-lua-scripting/">deciding that scripting the AI in straight Lua wasn't for me</a>, I cast around looking for another solution for my game's AI routines. I eventually settled on behavior trees.</p> <p>As of April, 2019, this is the AI solution for Gemini Rising going forward.</p> <h3>But What About State Machines?</h3> <p>The short answer is: the combinatorial explosion of states for any reasonably "smart" behavior violated my <strong>be easy for me</strong> rule of hobbyist game development.</p> <p>The bog-standard answer to "what should I write my game AI with", state machines represent a very natural way of describing how your game enemies "think". If your enemy is in the <code>STAND_GUARD</code> state then they are standing in one place, looking for the player; if your enemy is in the <code>PATROL</code> state then they are walking around.</p> <p>I find that state machines become unwieldy when trying to model complex behaviors. If there is anything cross-cutting about your enemies' behavior then the number of states you have to manage is going to explode. Is the enemy <code>SHOOTING_WHILE_STANDING_GUARD</code> or are they <code>SHOOTING_WHILE_ON_PATROL</code>?</p> <p>It matters because your "shooting" state must know what state to return to based on world events. If the enemy can no longer see the player, it must "remember" if it was standing guard or patrolling. The way to do that is to have two "shooting" states, one for standing guard and another for patrolling. That's not ideal.</p> <p>The solution for this problem is "hierarchical state machines". The cross-cutting behaviors become higher-level states (<code>PATROL</code>, <code>STAND_GUARD</code>) while the lower-level behaviors are states within those higher-level states (<code>SHOOTING</code>, <code>RUNNING_AWAY</code>). While it does address the combinatorial state explosion problem, it introduces two more problems:</p> <ol> <li>How do I re-use states across hierarchies, or among different enemies?</li> <li>There are no lua libraries I can find that do HSMs.</li> </ol> <p>Lots of my enemies shoot things. Lots of my enemies path find. How do they handle state changes given that when to change state, and to what, is enemy dependent? Now I've got an explosion of transition logic, which kicks the can around but doesn't address it exactly.</p> <p>To top it all off, I have to write it myself? Ugh.</p> <p>This all violates one of my goals for the AI of my game: <strong>Be easy for me</strong>. Too much state wrangling and not enough at-a-glance interpretability squanders my precious hobbyist game dev time. It's hard to overstate the importance of this goal: I have extremely limited time resources, so opportunity costs are hard and real. If I have to write and maintain a bunch of extra code below the AI routines for my enemies then I'm doing a lot of extra work. That extra works costs me as I have to delay improving my game to fix its bugs.</p> <p>That said, I did find some valuable resources along the way:</p> <ul> <li><a href="https://github.com/kyleconroy/lua-state-machine">kylecontrol/lua-state-machine</a> I had used the JavaScript version of this library before and I liked it a lot. This translation into lua was just great. I'm still using this for my animations.</li> <li><a href="https://statecharts.github.io/">Statecharts</a> Having a visual editor for a state machine would be neat, and they are hierarchical. Alas, I discovered this one once I was already sold on behavior trees. Maybe next time!</li> <li><a href="https://gameprogrammingpatterns.com/state.html">Game Programming Patterns: State</a> This book is a fantastic reference that every hobbyist game programmer should buy.</li> </ul> <h2>Behavior Trees</h2> <p>As is my wont, I'm not going to introduce what behavior trees are. Other authors have done much better jobs of that. <a href="http://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php">This is my favorite behavior trees intro</a>.</p> <p>I couldn't find a good behavior tree implementation in Lua so I wrote my own. Initially, I wanted my BT implementation to be functional and very, very simple. Since each node in a behavior tree can participate in the part-whole hierarchy of the tree, I figured that every node, at its heart, would look like this:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(entity, dt)</span></span> <span class="hljs-comment">-- Behavior tree stuff goes here.</span> <span class="hljs-keyword">end</span></code></pre> <p>The expected return values from this function should be one of <code>success</code>, <code>failure</code>, or <code>running</code>.</p> <p>It doesn't get much simpler than that.</p> <h2>In Which I Make Things More Complicated</h2> <p>Coders gonna code, as they say, and I regret the waffling I did while pursuing this solution and the code I committed, removed, re-wrote, tested, removed, then revamped along the way. But at least my game ended up better for it... hopefully.</p> <h3>To Restart Or Not To Restart?</h3> <p>The first hurdle I ran into was a surprisingly basic one. Given that <code>sequence</code> and <code>selector</code> iterate their children, what do they do if a child returned <code>running</code> the last time the tree was ticked?</p> <p>Does the tree return immediately to that node on the next tick? Or does it evaluate every node that came "before" that <code>running</code> node?</p> <p>The literature I've found is surprisingly unclear on the subject. Some sources insist on re-evaluating the entire tree every tick, some sources say to maintain a list of the nodes that are <code>running</code> as of last tick and return to re-evaluate those. Most that I was able to find didn't mention this at all, taking it as some obvious baseline assumption that I didn't have.</p> <h3>Restarting</h3> <p>If the tree nodes that have children restart on every tick, then it's easy for the tree to respond instantly to outside stimulus. I can place the behaviors that have higher priority <em>before</em> lower priority children in <code>sequence</code> and <code>selector</code> nodes and be assured that they will be evaluated as often as possible.</p> <p>Imagine a tree like this:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">return</span> sequence({ checkForHurt(), attackPlayer(), trackTarget(), investigateNoise(), patrol(), })</code></pre> <p>Each one of those functions returns a behavior tree node; in this implementation, a function.</p> <p>When guards attack the player, they fire three shots in a row and wait a little bit before firing again. This timing node became <em>super</em> complex because of this re-entrant behavior that I'd coded into the iterating nodes. Did that wait increment all the time, even if the node didn't get ticked this update? Did it remember the last timestamp instead?</p> <p>Guards would ignore noises as they tracked their targets and were too easy to fool. If I swapped the order of those nodes, now they would ignore their targets if anything made noise nearby. Neither one was correct, but fixing it involved a lot of conditional nodes polluting the lower branches of the tree.</p> <h3>Not Restarting</h3> <p>To fix this, I thought I should move to a (gasp) OOP solution for my nodes. By <a href="https://www.venganza.org/">the FSM</a>, I was building a tree so I should have some <code>Node</code> instances in there. These <code>Node</code> instances would maintain some state about what child was last <code>running</code> and would tick it directly.</p> <p>There was a case I hadn't considered in all of this: <code>parallel</code> nodes. A <code>parallel</code> node could have two children side-by-side, and one could be <code>failed</code> while the other was <code>running</code>. This would cause the <code>parallel</code> node to return <code>failed</code> and would interrupt the <code>running</code> node. Thus, there was still restarting in there.</p> <p>If I didn't restart the node but tracked the node that was running, then <em>surely</em> I needed <code>enter</code> and <code>exit</code> semantics on all my nodes, to make sure that the node restarted if it didn't get "picked" on the next tick.</p> <p>Suddenly, instead of a clean, functional solution I was surrounded by bloated objects. Most of them had empty <code>enter</code> and <code>exit</code> routines, but I still had to dutifully <code>enter</code> and <code>exit</code> nodes in my <code>sequence</code>, <code>selector</code>, and <code>parallel</code> nodes. Yuck.</p> <h3>Resolution</h3> <p>This plagued me throughout my initial exploration of this space as I flipped back and forth between the two. At one point, I decided that <code>sequence</code> should always return to its previously <code>running</code> child and <code>selector</code> should always evaluate from the beginning. That was supremely dumb; now the two most basic nodes of any behavior tree had different behaviors that made them harder to reason about. Ugh.</p> <p>Every flip of this behavior made me re-write the AIs for the two enemies I was using to test the AI. This cost me a lot and stalled the project for much longer than it should have.</p> <p>The advice that kicked me over the edge came from <a href="http://www.pandabehaviour.com/?page_id=23">Panda BT</a>, a good-looking behavior tree plugin for Unity. In its documentation was this advice:</p> <figure><blockquote> <p>Editing a behaviour tree is similar to writing a computer program: you donâ€™t specify the transitions from an instruction to another, since the transition is implied by the syntax of the programming language. This <strong>programming analogy</strong> is the based idea that inspired the development of Panda Behaviour.</p> </blockquote><figcaption>Panda BT Documentation</figcaption></figure> <p>A <strong>programming analogy</strong>. That kicked me out of my wishy-washy design headspace. I decided to imitate virtually every programming language I've ever used and iterate the statements in the order they were "written" until they were complete.</p> <p>I threw away my OOP solution that I was never happy with and ended up with much simpler code. Here is a <code>sequence</code> node:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(children)</span></span> <span class="hljs-keyword">local</span> index = <span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(entity, dt)</span></span> <span class="hljs-keyword">while</span> index &#x3C;= #children <span class="hljs-keyword">do</span> <span class="hljs-keyword">local</span> current = children[index] <span class="hljs-keyword">local</span> result = current(entity, dt) <span class="hljs-keyword">if</span> result == <span class="hljs-string">'failure'</span> <span class="hljs-keyword">then</span> index = <span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'failure'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> result == <span class="hljs-string">'running'</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'running'</span> <span class="hljs-keyword">end</span> index = index + <span class="hljs-number">1</span> <span class="hljs-keyword">end</span> index = <span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'success'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre> <p>And here is a <code>selector</code> node:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(children)</span></span> <span class="hljs-keyword">local</span> index = <span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(entity, dt)</span></span> <span class="hljs-keyword">while</span> index &#x3C;= #children <span class="hljs-keyword">do</span> <span class="hljs-keyword">local</span> current = children[index] <span class="hljs-keyword">local</span> result = current(entity, dt) <span class="hljs-keyword">if</span> result == <span class="hljs-string">'success'</span> <span class="hljs-keyword">then</span> index = <span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'success'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> result == <span class="hljs-string">'running'</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'running'</span> <span class="hljs-keyword">end</span> index = index + <span class="hljs-number">1</span> <span class="hljs-keyword">end</span> index = <span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'failure'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre> <p>Much better. The tests became simpler too since there was virtually no internal state to manage.</p> <h2>Doing Too Much</h2> <p>Throughout much of my AI exploration, I had pushed almost all complex behavior of my sprites into the AI routines. When something had to <code>wanderOnPlatform</code> then, <a href="https://www.venganza.org/">by FSM</a>, it would calculate everything it needed in its <code>wanderOnPlatform</code> routine (whether OOP or a closure). Originally, that meant casting rays from the entity to the platform below looking for edges.</p> <p>This strained the AI system and made everything more complex. Each node swelled in size as it began to manage its own slice of complicated state.</p> <p>This made it hard to find the reuse limits of the behavior nodes. I had to increasingly parameterize the AI nodes which moved split the definition of an entity between its definition and its AI tree. If I had two trees (such as <code>guardPatrol</code> and <code>guardStatic</code>) then I'd have to either duplicate or externalize those parameters to keep them consistent. This felt very fragile to maintain.</p> <h3>Memory</h3> <p>The first decision I made that eased the burden was adding a <a href="https://en.wikipedia.org/wiki/Blackboard_(design_pattern)">blackboard</a>. I didn't just want a way to share state among the nodes; I wanted something that would make the entities look more like they were really thinking. So I implemented my blackboard as a memory system. <a href="https://www.gamedev.net/articles/programming/artificial-intelligence/memory-markers-r4142/">Something like this memory markers system</a>.</p> <p>Every memory in the system would be stored via a particular <code>key</code>. The memory object itself would have two properties: a <code>value</code> for whatever the node wanted to remember and a <code>time</code> that the memory was stored. Different entities could remember things for different lengths of time, representing different threat profiles. Guards would remember things for much longer than sentries, for example.</p> <p>The memory data also breaks out the <code>x</code> and <code>y</code> position of the memory, since so much of the memory data is based on position.</p> <p>Suddenly nodes could operate on the memory instead. <code>hasTarget</code> could look for the <code>target</code> memory. <code>hasSeenPlayer</code> could look for the <code>player</code> memory. <code>targetTheHurt</code> would find the <code>hurt</code> memory and look for its normal.</p> <h3>Better Systems</h3> <p>It was only after I played around with goal-oriented action planning, though, that I realized I should formalize the "language" of my AIs with components and systems that represented that "language". For example, if multiple entities were trying to target the player, then there should be a <code>TargettingSystem</code> that tracked where the player was, if entities could see it, how long ago that was, etc.</p> <p>Thinking about my game in terms of the "verbs" of the game helped define the systems and their responsibilities. I wanted entities that could "see" the player, could "track" where they went.</p> <p>Another great example is the <code>NavMeshSystem</code>. Rather than relying on physics to determine where an entity could walk on a platform or fly through the level, I can pre-compute these areas and store them as navigation meshes. That way, when something goes to <code>wanderOnPlatform</code> it can look up where it is in the <code>platform</code> navmesh and find the edges very rapidly and simply.</p> <p>The <code>SensesSystem</code> takes care of sight and hearing for those entities that have <code>sight</code> and <code>hearing</code> components. The <code>AwarenessSystem</code> tracks entities that can have <code>low</code>, <code>medium</code>, or <code>high</code> awareness based on that sensory data and how it changes the parameters of their behavior. The <code>SteeringSystem</code> is responsible for moving the entity based on if it is <code>chase</code>-ing the player, <code>arrive</code>-ing at a target point, or simply <code>stop</code>-ped.</p> <p>And on and on. These systems pulled the weight off the AI's shoulders, so to speak, and the AI routines became very easy to write and reason about. Combined with the "don't restart" decision, scripting the AI became much more straightforward.</p> <h2>OOP vs. Functional</h2> <p>It seems so natural: I need to make a tree of nodes that mostly look the same. Some are going to differ in their implementation. Sounds like polymorphism to me!</p> <p>Except that nearly triples the amount of code I have to write for not much benefit. It also encouraged a mindset that made the nodes more complicated than they really should be.</p> <p>Here is the final implementation for <code>isAware</code>, a node that compares the entity's awareness level, written as a function:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(level)</span></span> <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(entity)</span></span> <span class="hljs-keyword">if</span> entity.awareness <span class="hljs-keyword">and</span> entity.awareness.level == level <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'success'</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'failure'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre> <p>It returns a function that has our node signature: <code>function(entity, dt) end</code>, while maintaining the state of the level we care about in the closure.</p> <p>Here is that implementation as OOP, using <code>classic</code> as our library of choice:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">local</span> Node = <span class="hljs-built_in">require</span> <span class="hljs-string">'core.behaviortree.node'</span> <span class="hljs-keyword">local</span> IsAware = Node:extend() <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsAware:new</span><span class="hljs-params">(level)</span></span> <span class="hljs-built_in">self</span>.level = level <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsAware:update</span><span class="hljs-params">(entity)</span></span> <span class="hljs-keyword">local</span> aware = entity.awareness <span class="hljs-keyword">if</span> aware.level == <span class="hljs-built_in">self</span>.level <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'success'</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'failure'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> IsAware</code></pre> <p>The OOP version is fully twice as long. There's a lot of OOP ceremony in there around overriding methods and showing the inheritance hierarchy. The visual noise detracts from the heart of what this thing actually does.</p> <p>And in case you think this example is contrived, this is among the simplest AI nodes I have that could be re-used across a bunch of different entities.</p> <h1>Final Example</h1> <p>Here is the <code>sentryPatrol</code> behavior tree as of April, 2019:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">surprise</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> sequence({ setMemory(<span class="hljs-string">'isSurprised'</span>, <span class="hljs-literal">false</span>), checkSurprise(), setMemory(<span class="hljs-string">'isSurprised'</span>, <span class="hljs-literal">true</span>), playSoundOnce(<span class="hljs-string">'sentrySurprised'</span>), stop, wait(<span class="hljs-number">.5</span>), setMemory(<span class="hljs-string">'isSurprised'</span>, <span class="hljs-literal">false</span>) }) <span class="hljs-keyword">end</span> <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pesterPlayer</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> sequence({ canSeePlayer, withinRange, clearMemory(<span class="hljs-string">'noise'</span>), bombPlayer(<span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-string">'floating'</span>, love.<span class="hljs-built_in">math</span>.<span class="hljs-built_in">random</span>(<span class="hljs-number">.5</span>, <span class="hljs-number">.8</span>)), }) <span class="hljs-keyword">end</span> <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trackTarget</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> sequence({ hasTarget, flyTrackTarget, }) <span class="hljs-keyword">end</span> <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">investigateNoise</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> sequence({ hasMemory(<span class="hljs-string">'noise'</span>), targetMemory(<span class="hljs-string">'noise'</span>), }) <span class="hljs-keyword">end</span> <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patrol</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> sequence({ isAware(<span class="hljs-string">'low'</span>), flyPatrol(), gotoNode(), waitRandom(<span class="hljs-number">1.5</span>, <span class="hljs-number">3</span>) }) <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> parallel({ surprise(), selector({ hasMemoryWithValue(<span class="hljs-string">'isSurprised'</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>), pesterPlayer(), trackTarget(), investigateNoise(), patrol(), }) }) <span class="hljs-keyword">end</span></code></pre> <p>This is the entire module named <code>sentryPatrol.lua</code> from Gemini Rising's codebase. It's not complete, but it's very close to what I imagine the final behavior of sentries should be in the game.</p> <p>The function that is <code>return</code>-ed at the bottom is the tree itself. The other top-level local functions represent potentially re-usable nuggets of behavior that I might put in their own modules.</p> <p>First, the sentry is always ready to be surprised. "Surprise" is defined as an entity's awareness level going up, from <code>low</code> to <code>medium</code> or <code>high</code>, or from <code>medium</code> to <code>high</code>. If it is surprised, then it pauses all other behavior until it is done showing its surprised behavior to the player. This allows the player a little reaction time if they hear or see a sentry that is now aware of them.</p> <p>The <code>selector</code> node defined at the root of the tree shows what behaviors this sentry will prioritize:</p> <ol> <li>If need be, it will do nothing as it acts surprised.</li> <li>It will bomb the player as long as the player can be seen and is within range.</li> <li>If it has a target, it will track that target.</li> <li>If it knows about any recent noise, it'll set that as a target.</li> <li>If nothing else is going on then it will fly its horizontal patrol route.</li> </ol> <p>The <code>SensesSystem</code> automatically targets the player if they are seen. This is part of that "lean on the language of the systems" thing I was writing about earlier. In this case, I don't have to write an AI routine to remember to target the player because <em>I always want my enemies targetting the player</em>. That's just the default. I'm not writing a general-purpose <code>SensesSystem</code>, I'm writing Gemini Rising's <code>SensesSystem</code> and that's the definition of how enemies work in this game.</p> <p>This script also matches my requirements. It has <strong>at-a-glance readability</strong>, it is <strong>predictable</strong> as a function of player behavior, and it's actually pretty <strong>fun</strong> trying to dodge a pack of these things as they try to bomb you when you're playing.</p> <h2>Further Reading</h2> <p>Here are the behavior tree links that helped me the most:</p> <ul> <li><a href="http://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php">Behavior trees for AI: How they work by Chris Simpson</a></li> <li><a href="http://www.pandabehaviour.com/?page_id=23">Panda BT's documentation</a></li> <li><a href="https://gamedev.stackexchange.com/questions/51693/difference-between-decision-trees-behavior-trees-for-game-ai">Difference between Decision Trees &#x26; Behavior Trees for Game AI</a></li> <li><a href="https://gamedev.stackexchange.com/questions/51738/behavior-trees-actions-that-take-longer-than-one-tick">Behavior Trees :: Actions That Take Longer Than One Tick</a></li> <li><a href="http://jahej.com/alt/2011_02_24_introduction-to-behavior-trees.html">Introduction to Behavior Trees - #AltDevBlog</a></li> <li><a href="http://leamonde.net/posts/11232015.html">Advanced Behavior Tree Structures</a></li> </ul> <p>Note that the "Actions That Take Longer Than One Tick" confused the hell out of me, because the accepted answer seems to offer contradictory advice: you should both go straight back to the running node <em>and</em> you should still evaluate higher priority nodes first. This was the original source of the "<code>selector</code> restarts but <code>sequence</code> does not" fiasco. That really sucked.</p> <p>Now I believe that the author was assuming that the root node was something like a <code>parallel</code> node. A <code>parallel</code> would still evaluate the "higher-priority" nodes.</p> <h2>Conclusion</h2> <p>Behavior trees rule. Behavior trees are my goto AI scripting solution for Gemini Rising. I imagine I'm going to use them for more than just entity AI in this game as well, but that's a blog post for another time.</p> <p>But in line with my general experience reading about stuff on the web, I wish I'd seen more recommendations about how to implement and use them effectively. Hopefully I've helped there somewhat.</p></content>
</entry>
<entry>
<title>Gemini Rising AI - Goal-Oriented Action Planning</title>
<link href="https://drhayes.io/blog/gemini-rising-ai-goap/"/>
<updated>2019-10-25T15:32:01-00:00</updated>
<id>https://drhayes.io/blog/gemini-rising-ai-goap/</id>
<content type="html"><p>This post is the (long overdue) third post in a series I'm writing about <a href="https://drhayes.io/blog/gemini-rising-ai-intro/">scripting the AI in my game, Gemini Rising</a>. This one is about goal-oriented action planning, or GOAP.</p> <p>I'm often frustrated to find that the blog posts I read don't dig into enough details about the <em>why</em> of things, instead focusing on very basic <em>what</em>s. With these posts, I'm trying to change that. Let's dive in.</p> <p>UPDATED 2020-07-13: Added 'game-ai' tag.</p> <h2>Intro</h2> <p>Before deciding on behavior trees for the AI of <a href="https://drhayes.io/games/gemini-rising">Gemini Rising</a>, I flirted with using GOAP. Simply put, GOAP involves giving your actors goals and a collection of actions. The goal is represented as a desired world-state. The actions have metadata that shows how taking that action mutates the world-state. The actors then path-find through the space of sequences of actions to see if any sequence will help them reach their goals.</p> <p>GOAP has been used in many video games, most notably perhaps in F.E.A.R. It's very interesting, surprisingly simple... and complete overkill for my project. I ended up removing it from Gemini Rising. However, the decisions that I made along the way of exploring GOAP helped me create an improved implementation of behavior trees, so I consider it worth the effort. Mostly.</p> <p>As is my wont in these articles, I'm not going to go in-depth in defining what GOAP is. For that, I'd refer you to the <a href="http://alumni.media.mit.edu/~jorkin/goap.html">GOAP site itself</a>, as well as a <a href="http://alumni.media.mit.edu/~jorkin/GOAP_draft_AIWisdom2_2003.pdf">paper written by Jeff Orkin, the guy who originated the technique</a>. Another good reference is <a href="https://gamedevelopment.tutsplus.com/tutorials/goal-oriented-action-planning-for-a-smarter-ai--cms-20793">this gamedev tutsplus article about GOAP</a> with some nice examples.</p> <h2>Goals</h2> <p>I like to think of my game's enemies as maintaining to-do lists that look something like this:</p> <ol> <li>Say ouch if I'm hurt.</li> <li>Kill the player.</li> <li>Investigate noises.</li> <li>Patrol around looking for player.</li> </ol> <p>With GOAP, that's precisely what they did. Here's an abbreviated snippet of code from my game's guards:</p> <pre><code class="hljs language-lua">guardPatrol = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">local</span> patrol = WorldState(<span class="hljs-string">'patrol'</span>) <span class="hljs-keyword">local</span> investigateNoise = WorldState(<span class="hljs-string">'investigateNoise'</span>) <span class="hljs-keyword">local</span> killPlayer = WorldState(<span class="hljs-string">'killPlayer'</span>) <span class="hljs-keyword">local</span> waitForPlayer = WorldState(<span class="hljs-string">'waitForPlayer'</span>) <span class="hljs-keyword">local</span> respondToHurt = WorldState(<span class="hljs-string">'respondToHurt'</span>) <span class="hljs-keyword">return</span> { respondToHurt, killPlayer, waitForPlayer, investigateNoise, patrol, } <span class="hljs-keyword">end</span>,</code></pre> <p>The only thing I've removed is how I further defined the <code>WorldState</code> instances. Those <code>WorldState</code> instances are the goals. The list of instances I'm returning from this function define the hierarchical order of goals this entity will pursue.</p> <p>Each <code>WorldState</code> is a collection of key-value pairs. The GOAP code can compare two <code>WorldState</code> instances using the <code>matches</code> method that I wrote:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WorldState:matches</span><span class="hljs-params">(otherState)</span></span> <span class="hljs-keyword">for</span> k,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.matchSpec) <span class="hljs-keyword">do</span> <span class="hljs-keyword">local</span> otherValue = otherState.matchSpec[k] <span class="hljs-keyword">if</span> otherValue == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> otherValue = <span class="hljs-literal">false</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-string">'boolean'</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(otherValue) ~= <span class="hljs-string">'boolean'</span> <span class="hljs-keyword">then</span> otherValue = <span class="hljs-keyword">not</span> <span class="hljs-keyword">not</span> otherValue <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> value ~= otherValue <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">end</span></code></pre> <p>This code worked, but felt very hacky to me. The most common value in the <code>WorldState</code> instances is a boolean. If a given <code>WorldState</code> has no value for a given key, it's a kind of "don't care" value; a <code>nil</code> will match the <code>WorldState</code> it's getting compared to if the other's value is <code>true</code> or <code>false</code>. I had unit tests guaranteeing that part worked, so I forgave myself the unclear code (how magnanimous of me) and moved on.</p> <h2>Actions</h2> <p>Actions encompass two concepts:</p> <ol> <li>A precondition that must be true to take this action.</li> <li>A resultant world state that is true once this action is complete, called the effect.</li> </ol> <p>To move from the precondition to the resultant state, the entity must take this action... if it can. Sometimes the state of the world prevents an entity from taking a particular action. The planner verifies this by matching the precondition against the current world state using the <code>WorldState:matches</code> method from before.</p> <p>Once the action is complete, we modify the "current" world state to include the effect of the action.</p> <p>"Hold up!" I imagine you saying. "I've recently seen a way to match world states." You're correct, astute reader. <code>WorldState</code> instances act as the state of the world, the precondition of actions, and the resultant world state for every action (the effect). That's convenient and a little bit poetic: I know about the current <code>WorldState</code>, and my goals are defined as desired <code>WorldState</code>s as well. Anyway.</p> <p>Each of the actions the entity can take make a path to a goal.</p> <h2>Pathfinding? Really?</h2> <p>One of the more interesting things about GOAP is its use of <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> that is not directly related to spatial pathfinding. If you think of the space of actions the entity can take as paving stones on the way to a goal this seems like a natural idea. When I first encountered it I was gobsmacked -- what an elegant solution.</p> <p>Each action is given a cost. This cost is paid by the entity for performing this action. The entity will likely find multiple sequences of actions that result in it completing its highest-priority goal. The planner picks the sequence with the lowest cost as the "best" course of action.</p> <p>Simple costs might include "distance to target", "amount of damage I'll suffer", or "amount of ammo I'll use". Anything that will help the entity pick the "best" goal.</p> <p>My initial implementation had startling and effective results without using cost, however. But I thought this was a neat feature of this solution.</p> <h2>Systems</h2> <p>All this theory is great, but what happened when I started trying to implement it in practice?</p> <p>When it came time to make actions for my entities I realized that my entities couldn't see anything, couldn't hear anything, didn't track when they were last hurt, didn't know where the player was five seconds ago... nothing! Their "brains" were basically non-existent.</p> <p>In behavior tree land, most of these "smarts" were wrapped up in the nodes of the behavior tree. Each node basically took care of how it managed its own state from traversal to traversal. This hadn't been a problem in behavior tree land (so I thought... foreshadowing!) but was definitely a problem now.</p> <p>Since I was no longer using custom behavior tree nodes, how could my entities respond to a noise if they couldn't hear it or remember its position?</p> <h3>Entity Memory</h3> <p>I needed to give my poor little entities some way to remember what they'd encountered in the game. So I gave them memory.</p> <p>Here's the <code>set</code> method on the <code>AISystem</code>:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AISystem:set</span><span class="hljs-params">(entity, key, value, posX, posY, normalX, normalY)</span></span> <span class="hljs-keyword">local</span> brain = entity:get(Brain) <span class="hljs-keyword">local</span> memory = brain:get(key) <span class="hljs-keyword">if</span> memory <span class="hljs-keyword">then</span> memory.<span class="hljs-built_in">time</span> = <span class="hljs-built_in">self</span>.<span class="hljs-built_in">time</span> memory.value = value memory.posX = posX memory.posY = posY memory.normalX = normalX memory.normalY = normalY memory.forgotten = <span class="hljs-literal">false</span> <span class="hljs-keyword">else</span> memory = { <span class="hljs-built_in">time</span> = <span class="hljs-built_in">self</span>.<span class="hljs-built_in">time</span>, value = value, <span class="hljs-comment">-- can also be a flag, true/false</span> posX = posX, posY = posY, normalX = normalX, normalY = normalY, forgotten = <span class="hljs-literal">false</span>, <span class="hljs-comment">-- [0, 1] based on memory span of brain holding memory.</span> age = <span class="hljs-number">0</span> } <span class="hljs-keyword">end</span> brain:set(key, memory) <span class="hljs-keyword">return</span> memory <span class="hljs-keyword">end</span></code></pre> <p>There's some ECS ceremony in there but, essentially, my entities store their memories in their brain components. Each memory is a key, a value, a position, and possibly a normal to make my life easier down the road. Position is optional but almost always used. Normal is optional and only ever used when remembering being damaged. But I'm jumping ahead of myself.</p> <p>If we've seen this memory before, don't make a new object -- just update the existing object with new values. If it's new, make a new object and store the values. Done. Simple.</p> <p>Here's how we <code>get</code> memories back out:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AISystem:get</span><span class="hljs-params">(entity, key, withinSpan)</span></span> <span class="hljs-keyword">local</span> brain = entity:get(Brain) <span class="hljs-keyword">local</span> memory = brain:get(key) <span class="hljs-comment">-- Did we ever know this?</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> memory <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">end</span> <span class="hljs-comment">-- Set its age, how long this memory is going to last within memory span.</span> <span class="hljs-keyword">local</span> timeDelta = <span class="hljs-built_in">self</span>.<span class="hljs-built_in">time</span> - memory.<span class="hljs-built_in">time</span> memory.age = lume.clamp(timeDelta / brain.memorySpan, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">-- Check if this is forgotten now.</span> <span class="hljs-keyword">if</span> memory.forgotten <span class="hljs-keyword">or</span> timeDelta > brain.memorySpan <span class="hljs-keyword">then</span> memory.forgotten = <span class="hljs-literal">true</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">end</span> <span class="hljs-comment">-- Is this within the time span they want?</span> <span class="hljs-keyword">if</span> withinSpan <span class="hljs-keyword">and</span> timeDelta > withinSpan <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> memory.transient <span class="hljs-keyword">then</span> memory.forgotten = <span class="hljs-literal">true</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> memory <span class="hljs-keyword">end</span></code></pre> <p>It's commented, so I won't repeat any of that info here. I <em>will</em> say that whether a memory is "transient" ended up not mattering. Normalizing the age helped with debugging and made it possible to have "urgent" goals, like "This just happened so increase my alarm state!". <code>withinSpan</code> mostly complicated things without much benefit. But the basic code is good: if I've got this memory, return it.</p> <p>I've moved on from GOAP (spoiler alert!), but this code is still in my game. Having a memory makes so many other AI decisions possible and much, much easier. I'm kind of sorry it took me so long to get here.</p> <p>Where was I hit? Where did I last see the player? Where was that noise? All these questions can be asked of the memory. But what writes to those memories?</p> <h3>Entity Senses</h3> <p>Once memory was in place, I naturally moved on to senses. If an entity could see a player, then the <code>SensesSystem</code> would execute this line:</p> <pre><code class="hljs language-lua"> aiSystem:set(entity, <span class="hljs-string">'player'</span>, <span class="hljs-number">1</span>, util.entityMiddle(thing))</code></pre> <p><strong>I JUST SAW THE PLAYER</strong> this line says. <strong>HERE'S WHERE I THINK THE PLAYER IS</strong> it screeches.</p> <p>It's hard to state how powerful this one line of code ends up in every single AI routine that I write now. Once I give an entity senses, it will note where the player is. Anything else that needs to know where the player is will ask the entity's memory, not the game world. This provides a nice-looking, "realistic" behavior of sentries that act like bloodhounds, chasing down the player even when the player jumps down through floors and guards that stand where the player just was waiting for them to come back.</p> <p>Being hurt adds a memory, too, if the entity has a brain. That's in the <code>HealthSystem</code>.</p> <p>I can heap praise on this solution because it's not mine. I found <a href="https://www.gamasutra.com/view/feature/131297/building_an_ai_sensory_system_.php">this great article about the sense system in Thief</a> and put in a stripped-down version into my game. It worked wonders.</p> <p>Hearing works the same way, but is more concerned with noise:</p> <pre><code class="hljs language-lua"> aiSystem:set(entity, <span class="hljs-string">'noise'</span>, noise.level - distance, noise.x, noise.y)</code></pre> <p>Same principle applies. <strong>WHAT WAS THAT NOISE</strong> this line yells.</p> <p>And the enemies jump to reply.</p> <h3>Entity Movement</h3> <p>My previous behavior tree solution spent a lot of time concerning itself with physics. Any node that moved the entity had to know how fast the entity was moving, what its max speed was, and how close it was to its destination.</p> <p>Here's the constructor of the <code>WalkForward</code> behavior tree node from before I switched to GOAP:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WalkForward:initialize</span><span class="hljs-params">(speed)</span></span> <span class="hljs-comment">-- code goes here</span> <span class="hljs-keyword">end</span></code></pre> <p>The speed value indicates at what speed this entity should move. There are several such values per enemy. Those values vary by enemy, even if the "walk forward" behavior does not change across multiple behavior trees -- so I have to pass them in. I have to pass them in every time I use these nodes, in fact, even if I'm using the nodes for the same entity.</p> <p>Because of the way the nodes were written, to be a little generic, that meant a lot of duplicated code and lots of obfuscation of what each behavior tree node was actually doing. The behavior tree "brains" were very noisy to read.</p> <p>Thinking back, I could have implemented a registry of such values per entity that these nodes could pull from... but I think the solution I created for this works even better.</p> <p>I wanted something different for my GOAP actions. I wanted each one to be blissfully ignorant of how the entity's moved. Besides, I was fairly certain that mixing in the physics calculations with was a code smell and a failure of <a href="https://drhayes.io/parables/army-officers-test/">the army officer's test</a>. Shame on me.</p> <p>Enter nav meshes. Rather than constantly sending out rays to figure out where the basically static ground was every frame, what if my entities positioned themselves along the edges and vertices of a navmesh to determine where they were going? That would mean that I could generate any navmeshes that I needed for a level at level generation time (Gemini Rising is procedurally generated, but you probably knew that) and not have to worry about how entities move after that -- they just have a destination node and off they go!</p> <p>I ended up with two navmeshes, one for the things that walk on platforms and another for things that fly through the air. This solved lots of ancillary problems as well:</p> <ul> <li>How do things that walk on platforms know if they can jump to a nearby platform? The platforming navmesh can have vertices between edges that are navigable by jump.</li> <li>How do I make things that fly avoid platform edges? Simply don't place flight navmesh nodes too close to platforms. They literally won't be able to path near the platform edge.</li> <li>Eventually, I plan on making enemies that can teleport via stationary bases from one area of the map to another. In a completely physics-based pathfinding scenario it'd be hard to configure teleporting through a base as a valid route. In a navmesh world, the stationary base becomes a vertex that gets pathed through. Easy.</li> </ul> <p>So, I did that. But having a destination isn't quite enough -- how do you get there? I mean, once the pathfinder has figured out what points you need to hit in the navmesh to get to your destination... what actually happens?</p> <h4>Steering</h4> <p>Why, the <code>SteeringSystem</code> takes over of course! It looks like this:</p> <pre><code class="hljs language-lua"><span class="hljs-keyword">local</span> System = <span class="hljs-built_in">require</span> <span class="hljs-string">'lib.concord.system'</span> <span class="hljs-keyword">local</span> Steering = <span class="hljs-built_in">require</span> <span class="hljs-string">'components.steering'</span> <span class="hljs-keyword">local</span> steeringBehaviors = <span class="hljs-built_in">require</span> <span class="hljs-string">'systems.steeringBehaviors'</span> <span class="hljs-keyword">local</span> SteeringSystem = System({ Steering }) <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SteeringSystem:update</span><span class="hljs-params">(dt)</span></span> <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">self</span>.pool.size <span class="hljs-keyword">do</span> <span class="hljs-keyword">local</span> entity = <span class="hljs-built_in">self</span>.pool:get(i) <span class="hljs-keyword">local</span> steering = entity:get(Steering) <span class="hljs-keyword">local</span> steer = steeringBehaviors[steering.behavior] <span class="hljs-keyword">if</span> steer <span class="hljs-keyword">then</span> steer(entity, dt) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> SteeringSystem()</code></pre> <p>Ignore the ECS ceremony for now, focus on the part where if I find a steering behavior in my <code>steeringBehaviors</code> map I invoke it with the entity and the <code>dt</code> since last frame.</p> <p>Here's my implementation of <code>seek</code>:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">behaviors.seek</span><span class="hljs-params">(entity, dt)</span></span> <span class="hljs-keyword">local</span> steering, pos, body = entity:get(Steering), entity:get(Position), entity:get(Body) <span class="hljs-keyword">local</span> destX, destY = steering.destX, steering.destY <span class="hljs-keyword">local</span> angle = lume.angle(pos.x, pos.y, destX, destY) <span class="hljs-keyword">local</span> dist = lume.distance(pos.x, pos.y, destX, destY) <span class="hljs-keyword">local</span> targetSpeed = steering.speed steering.arrived = <span class="hljs-literal">false</span> <span class="hljs-keyword">if</span> dist &#x3C; steering.targetRadius <span class="hljs-keyword">then</span> targetSpeed = <span class="hljs-number">0</span> steering.arrived = <span class="hljs-literal">true</span> <span class="hljs-keyword">elseif</span> dist &#x3C; steering.slowRadius <span class="hljs-keyword">then</span> targetSpeed = steering.speed * dist / steering.slowRadius <span class="hljs-keyword">end</span> body.vx = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">cos</span>(angle) * targetSpeed pos.facing = angle <span class="hljs-keyword">end</span></code></pre> <p>Check out that <code>slowRadius</code> stuff. That's pretty legendary. It makes enemies look very natural as the slow to a stop as they arrive at their destinations.</p> <p>As always when I praise something, it's because I got the idea from something else. My goto reference for the basics of AI game programming has always been <a href="https://smile.amazon.com/AI-Games-Third-Ian-Millington/dp/1138483974/ref=sr_1_1?keywords=artificial+intelligence+for+games&#x26;qid=1572234715&#x26;sr=8-1">AI for Games by Ian Millington</a>. I adore this book and have read it cover-to-cover multiple times. I have the second edition but I can only imagine the third edition is just as good.</p> <p>There are more steering behaviors like <code>stop</code>, <code>arrive</code>, <code>chase</code>, etc... but the GOAP-level action knows none of those things. All it knows is <code>gotoNode</code>. Entities decide how they get places -- the AI tells them where to go. That separation cleans everything up and pays off big when (spoiler alert!) I swapped out AI systems again after GOAP.</p> <h2>Examples</h2> <p>Now that the systems were in place to support my actions, I made a small palette of actions for my two test entities: a guard that paces along platforms looking for players and a flying sentry that goes on high alert when it sees a player and starts a chase that ends only when it "forgets" about the player.</p> <p>Here's a small sample:</p> <ul> <li><code>bombPlayer</code></li> <li><code>flyCircuit</code></li> <li><code>gotoHome</code></li> <li><code>playSound</code></li> <li><code>shootPlayer</code></li> <li><code>wanderOnPlatform</code></li> </ul> <p><code>wanderOnPlatform</code> is a nice barometer of how good my AI solution is treating me. Here's a snippet of the important bits:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WanderOnPlatform:new</span><span class="hljs-params">()</span></span> WanderOnPlatform.super.new(<span class="hljs-built_in">self</span>) <span class="hljs-built_in">self</span>.cost = <span class="hljs-number">5</span> <span class="hljs-built_in">self</span>.effect:set(<span class="hljs-string">'hasDestination'</span>, <span class="hljs-literal">true</span>) <span class="hljs-keyword">if</span> love.<span class="hljs-built_in">math</span>.<span class="hljs-built_in">random</span>() > <span class="hljs-number">0.5</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">self</span>.wanderDir = <span class="hljs-string">'left'</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">self</span>.wanderDir = <span class="hljs-string">'right'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WanderOnPlatform:run</span><span class="hljs-params">(entity)</span></span> <span class="hljs-keyword">local</span> pos, brain = entity:get(Position), entity:get(Brain) <span class="hljs-keyword">local</span> navTile = navMeshSystem:queryByPixelPos(<span class="hljs-string">'platform'</span>, pos.x, pos.y) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> navTile <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'failure'</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">local</span> ctx = brain.context <span class="hljs-keyword">local</span> dest = <span class="hljs-literal">nil</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.wanderDir == <span class="hljs-string">'left'</span> <span class="hljs-keyword">then</span> dest = navTile:leftMost() <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">self</span>.wanderDir == <span class="hljs-string">'right'</span> <span class="hljs-keyword">then</span> dest = navTile:rightMost() <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.wanderDir == <span class="hljs-string">'left'</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">self</span>.wanderDir = <span class="hljs-string">'right'</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">self</span>.wanderDir = <span class="hljs-string">'left'</span> <span class="hljs-keyword">end</span> brain.context.destination = dest aiSystem:set(entity, <span class="hljs-string">'hasDestination'</span>, <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'success'</span> <span class="hljs-keyword">end</span></code></pre> <p>There's the navmesh. There's the <code>effect</code>, which is the change to the world state for the entity after this action has been successfully run; that helps the planner figure out if it should use this action or not. Once it runs its job is complete; the steering system takes over as the entity wanders back and forth on the platform.</p> <p>Without the physics code intertwined here, and without having to worry about "jumping" out because the entity was just shot, this code is <em>very</em> simple. I was pretty happy.</p> <h2>Debugging</h2> <p>While setting goals and writing actions I needed some way of seeing what the entities thought was going on. I implemented a <code>debugDraw</code> method on my <code>AISystem</code> to help me out:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AISystem:drawDebug</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">self</span>.pool.size <span class="hljs-keyword">do</span> <span class="hljs-keyword">local</span> entity = <span class="hljs-built_in">self</span>.pool:get(i) <span class="hljs-keyword">local</span> brain = entity:get(Brain) <span class="hljs-keyword">if</span> brain.context.destination <span class="hljs-keyword">then</span> <span class="hljs-keyword">local</span> dx, dy = brain.context.destination:center() love.graphics.setColor(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">.5</span>) love.graphics.rectangle(<span class="hljs-string">'fill'</span>, dx - <span class="hljs-number">2</span>, dy - <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>) <span class="hljs-keyword">end</span> <span class="hljs-keyword">local</span> pos = entity:get(Position) <span class="hljs-keyword">local</span> actionManager = <span class="hljs-built_in">self</span>.actionManagers[entity] actionManager:drawDebug(pos.x, pos.y) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre> <p>It draws a rectangle to indicate an entity's destination (if it has one) and calls <code>actionManager:drawDebug</code>. All that does is this:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ActionManager:drawDebug</span><span class="hljs-params">(x, y)</span></span> <span class="hljs-keyword">local</span> name = <span class="hljs-string">'nil'</span> <span class="hljs-keyword">local</span> currentAction = <span class="hljs-built_in">self</span>.actions <span class="hljs-keyword">and</span> <span class="hljs-built_in">self</span>.actions[<span class="hljs-built_in">self</span>.current] <span class="hljs-keyword">if</span> currentAction <span class="hljs-keyword">then</span> name = <span class="hljs-built_in">tostring</span>(currentAction.class) <span class="hljs-keyword">end</span> love.graphics.setColor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) love.graphics.<span class="hljs-built_in">print</span>(name, x, y) <span class="hljs-keyword">end</span></code></pre> <p>These probably shouldn't have been separate methods, to be honest. But by printing what the action the entity is executing I can zero in on their confusing behavior.</p> <p>One more debug method rounded out my arsenal:</p> <pre><code class="hljs language-lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AISystem:keypressed</span><span class="hljs-params">(key, scancode, isRepeat)</span></span> <span class="hljs-keyword">if</span> key == <span class="hljs-string">'f2'</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">'ai state:'</span>) <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">self</span>.pool.size <span class="hljs-keyword">do</span> <span class="hljs-keyword">local</span> entity = <span class="hljs-built_in">self</span>.pool:get(i) <span class="hljs-keyword">local</span> brain = entity:get(Brain) <span class="hljs-keyword">local</span> ws = <span class="hljs-built_in">self</span>:convertBrainToWorldState(entity) <span class="hljs-built_in">print</span>(brain.goalListName, ws:<span class="hljs-built_in">debug</span>()) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre> <p>If I pressed F2 then I would get a dump of the state of every entity's world state and goal. This helped enormously when my entities inevitably ran wild, didn't shoot the perfectly available and obvious player, ran into things, and generally didn't behave as menacing enemies in a video game.</p> <h2>Complications</h2> <p>It didn't all work immediately. I found bugs and complications in my implementation that I didn't see anyone else write about. I don't know if that's because they're obvious, they're bugs I wrote because I don't understand what I'm doing, or what. <em>Â¿porque no los dos?</em></p> <h3>Timeouts</h3> <p>Some actions that I wrote required timeouts. I wanted certain enemies to give up if they couldn't reach the player within a certain time so they would try something else, but I wanted this to happen while they still remembered the player.</p> <p>Each entity's brain has an <code>ActionManager</code> that has a way of running sequences of actions. It maintains this timeout.</p> <h3>Planner Graphs</h3> <p>The planner builds a graph of actions. Paths through this graph become plans that satisfy goals. When I first wrote the planner, it would get stuck in infinite loops because I wasn't removing each action from the pool of available actions as I added them to the graph. This might have been a weakness in my preconditions and effects, however.</p> <h3>Dynamism</h3> <p>One of the strengths of this approach is the flexibility of the "list of actions" and "list of goals" approach. These lists become knobs that you can twist to modify the entity's behavior at run-time. I made no use of this and preferred to make my actions compensate instead.</p> <p>Imagine an entity that doesn't know to attack anything until an alarm in the level goes red, or an action called "flee" that isn't available until the entity's health is below 25%. Sure, you can specify this as a precondition on the action (which I mostly did), but maybe modifying the list of actions or goals would have further simplified my actions. I don't know.</p> <h2>Results</h2> <p>The enemies in my game became a lot smarter. Like, <em>way</em> smarter. <strong>Too smart</strong>.</p> <p>Whoops.</p> <p><a href="https://www.youtube.com/watch?v=4PLvdmifDSk">I was so preoccupied with whether or not I could that I didn't stop to think if I should.</a></p> <p>The behavior was most noticeable in the guards. You know, the ones whose number one to-do item is "kill the player". It was pretty easy to enable emergent behaviors like, "if there are already two guards shooting the player walk forward to be the closest," or "if there are four guards shooting at the player go find an alarm panel to sound the alarm". That's not the problem.</p> <p>The problem is that it actually stopped being fun.</p> <p>I think there's room in this world for games with really smart enemies, guards that corner the player and make them hide until they are eventually found and killed if they take no other action. Sentries that coordinate their attacks with suppressing fire while they leap-frog and advance upon the player's position. Enemies that have no discernable pattern, that swarm the player with overwhleming odds, and deny victory to all but the swiftest, most combat-oriented of players.</p> <p>But that's not the game I want to make.</p> <p>And, dammit, I'd spent a lot of time researching, designing, and implementing something that I was now about to rip out completely because <em>it didn't serve my game</em>. That's probably the worst part of all this, my wasted time and effort. Hopefully the lesson will stick this time.</p> <h3>Silver Lining</h3> <p>The silver lining of this is that the AI subsystems became <em>a lot</em> smarter in the process. When I returned to my behavior trees I was pleasantly surprised at how much easier they were this time around. But that's a topic for another blog post.</p></content>
</entry>
<entry>
<title>Captivated by Public Note Systems</title>
<link href="https://drhayes.io/blog/captivated-by-public-note-systems/"/>
<updated>2020-07-20T04:00:00-00:00</updated>
<id>https://drhayes.io/blog/captivated-by-public-note-systems/</id>
<content type="html"><p>I fell into an <a href="http://www.gnu.org/software/emacs/">emacs</a> hole the last couple of weeks. I'm liable to try any productivity system you put in front of me for at least a little bit, and emacs' <a href="https://orgmode.org/">org-mode</a> is pretty much the king. And I can definitely see the benefits of a fully developed <a href="https://karl-voit.at/tags/emacs/">org-based workflow</a>, especially as someone who constantly writes things down in little notebooks and <a href="https://keep.google.com/">various</a> <a href="https://evernote.com/">other</a> <a href="https://notion.so/">digital</a> <a href="https://standardnotes.org/">nooks</a>.</p> <p>The worst of these tools create piles of notes, impossible to organize. Slightly less worse are tools that trap my notes in proprietary systems I don't control. The only real answer is <a href="https://drhayes.io/tags/text">plain-text</a>, of course.</p> <p>The most ambitious plain-text, analog note system I've ever seen is <a href="https://en.wikipedia.org/wiki/Zettelkasten">zettelkasten</a>. Essentially, you write notes on index cards and assiduously tag and index them, keeping them forever in a slip box. Notes can refer to other notes in an ingenious analog addressing system.</p> <p>But what kicked me fully down this particular rabbit hole was finding <a href="https://www.ianjones.us/">Ian Jones' site</a>. I stumbled on one of his articles about <a href="https://www.ianjones.us/progressive-summarization-in-org-mode">progressive summarization in org mode</a> and basically found everything you see in this blog post. <del>I think this is the last formal "blog post" that I'm going to write for this site.</del> Okay, this is clearly not true as there are going to be date-related posts. But it's pretty close; most of the updated content is going to be on the notes side.</p> <h2>First steps to public plain text: now</h2> <p>The first thing I did was create a <a href="https://drhayes.io/now">"now"</a> page for my site. What am I working on, in general, right now? What are my interests? Which topics, if you broached them with me, would I not shut up about?</p> <p>Thanks to <a href="https://sivers.org/now">Derek Sivers</a> for the great idea. My now page is listed on his now site: <a href="https://nownownow.com/about">https://nownownow.com/about</a>.</p> <p><a href="https://drhayes.io/now">So here's what I'm doing right now</a>. I've also got <a href="https://notes.drhayes.io/notes/projects">a note listing the projects I've got on my mind</a>.</p> <h2>Next steps: public notes</h2> <p>I think <a href="https://tomcritchlow.com/">Tom Critchlow</a> has it right: this is a digital garden. Evergreen things will grow here that reflect my interests and what I discover along the way as these interests germinate, grow, mature, and fade away. The note itself is the result, not a means to some other end.</p> <p><a href="https://tomcritchlow.com/wiki/">Tom's wiki</a> is an interesting structure, but not quite what I want. There are great design ideas there that I want to steal, so here is credit given.</p> <p><a href="https://notes.andymatuschak.org/About_these_notes">Andy Matuschak's notes are probably my gold standard at this point</a>. I dig how interconnected they are, how the next note stacks on the previous, and how each note shows what links to this note. I'm excited to think about writing in my site and seeing what links develop in the browser as I write. Seems very powerful for preserving context and sending messages to my future self.</p> <p><a href="https://notes.busterbenson.com/">Buster Benson has a great notes section as well</a>. I especially appreciate his concept of piles and the Codex Vitae. More ideas to steal for my site.</p> <p><a href="https://joelhooks.com/digital-garden">Joel Hooks has a page that basically outlines my current thinking</a>. I think I'm going to transition my site away from a blog format and more towards a place where the knowledge I can offer is on display as I develop it.</p> <h2>Further in the future: A Personal Canon? An exocortex?</h2> <p>I was charmed to find <a href="http://www.brendanschlagel.com/canon/">Brendan Schlagel's personal canon</a> and I'm thinking about my own.</p></content>
</entry>
<entry>
<title>Root Log for Feb. 22, 2021</title>
<link href="https://drhayes.io/blog/root-log-2021-02-22/"/>
<updated>2021-02-22T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/root-log-2021-02-22/</id>
<content type="html"><h2>Overview</h2> <p>I am trying to document our Root games in a more regular, nerdy fashion so I can tighten up my thinking around the game itself and fine-tune my own strategies in general. We try to play at least once a week.</p> <p><a href="https://ledergames.com/products/root-a-game-of-woodland-might-and-right">Root</a> is my favorite board game in the world at the moment. It is hideously complex, and I've played more incorrect games than I have correct games, but we're getting there.</p> <h3>Game Setup</h3> <ul> <li>Factions <ul> <li>Me: Eyrie Dynasty</li> <li>Terra: Lizard Cult</li> <li>Alex: Marquise de Cat</li> </ul> </li> <li>Map: Mountain! (first time!)</li> <li>Deck: Normal</li> </ul> <h3>Final State</h3> <ul> <li>Eyrie won with 30 VP.</li> <li>Lizards had 29 VP.</li> <li>Marquise had 27 VP.</li> </ul> <h2>General Thoughts</h2> <p>I need to start taking nerdy notes on a per-turn basis so I'm not relying on my faulty memory to create these logs. I'm also going to get Terra and Alex to read it and see if they have any feedback or if I'm missing anything.</p> <p>Terra played an <em>amazing</em> game as the Lizards. She dominated the board throughout the game. We didn't do enough to contain her gardens and, in the end-game, the Lizard's ability to rule a clearing by virtue of having a garden created lots of movement pressure on the Birds and Cats.</p> <p>Based on my starting hand (two Bunny cards) and my initial roost clearing suit (Bunny), I picked the "Recruiter leader, stack recruit, go into turmoil first turn" strategy. That gave me an early lead on warriors in the game (twelve total). I picked the "Move and Battle" leader next, who deals an extra hit in battle as attacker. Great for when you have twelve warriors on the board. I went into turmoil one more time, after.</p> <p>Alex spent the early game clearing mountain paths at a VP-point-for-a-card cost. Post-game, he felt like doing that so early was a mistake.</p> <p>The Cats and Lizards were neck-and-neck with Birds catching up towards the end.</p> <h2>My Faction Performance</h2> <p>That weird recruiter startegy was lots of goofy fun. The birds continue to confound me, in general, even if I did win. It feels like barely being in control of a bucking bronco, to me, even as their plan is available and incrementally built.</p> <p>My early draw was <em>terrible</em>, no bird cards until the end-game. Terra did a great job positioning warriors underneath the grinding wheel of the Birds' Battle decree.</p> <p>Terra and Alex helped a lot, so my Bird play felt like a group effort at times. I don't mind the help, really.</p> <h2>Next Time</h2> <p>What about the Partisans deck? I'd love to spend more time with the Woodland Alliance in the near future, it's been too long.</p></content>
</entry>
<entry>
<title>Root Log for Feb. 27, 2021. First game.</title>
<link href="https://drhayes.io/blog/root-log-2021-02-27-1/"/>
<updated>2021-02-22T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/root-log-2021-02-27-1/</id>
<content type="html"><h2>Overview</h2> <p>I am trying to document our Root games in a more regular, nerdy fashion so I can tighten up my thinking around the game itself and fine-tune my own strategies in general. We try to play at least once a week.</p> <p><a href="https://ledergames.com/products/root-a-game-of-woodland-might-and-right">Root</a> is my favorite board game in the world at the moment. It is hideously complex, and I've played more incorrect games than I have correct games, but we're getting there.</p> <p>Our first co-op game against a bot player! We pretty much slaughtered it. Time to up the difficulty for next time.</p> <h3>Game Setup</h3> <ul> <li>Factions <ul> <li>Me: Woodland Alliance</li> <li>Terra: Vagabond</li> <li>Alex: Eyrie Dynasty</li> <li>Bot: Mechanical Marquise (Default)</li> </ul> </li> <li>Map: Starter</li> <li>Deck: Normal</li> </ul> <h3>Final State</h3> <ul> <li>Humans all won with 30 VP.</li> <li>Bot got to 22, I think?</li> </ul> <h2>General Thoughts</h2> <p>Co-op was lots of fun. I'm not sure we played it correctly. We realized that we were scoring the Marquise wrong towards the end of the game and were granting it too many points when it scored. Ooops.</p> <p>I don't think anyone felt like we were getting whomped by the bot; if anything, our VP totals were clumped together most of the game until close to the end. The Vagabond reached 30 first, then the Woodland Alliance, finally the Eyrie.</p> <p>A mid-game Favor of the Foxes killed the starting clearing for the Mechanical Marquise. Since it doesn't make particular use of its Keep so this was mostly like felling a forest so we could control the sapling growth.</p> <p>The bot never gained any particular position. The occasional bird card draw made for some interesting combats, but generally seemed helpful in maintaining the Eyrie decree or in creating outrage for the Alliance.</p> <p>A couple of interesting takes: co-op players are still considered enemies for purposes of Revolt, etc. A couple of times we human players purposefully zapped each other for temporary advantage, especially in the end-game.</p> <h2>My Faction Performance</h2> <p>Ah, the Woodland Alliance, my jam.</p> <p>I feel like I did a good job using Outrage to generate enough card draw to grow along the expected growth curve for the Woodland Alliance (vaguely polynomial; slow at the start, rushing at the end). We were all coordinating so I don't remember any particular turn of mine having an outsize contribution to the win.</p> <p>I continued my general strategy of almost never attacking with the Alliance but using warriors to spread sympathy late game.</p> <h2>Next Time</h2> <p>More difficult bot! Maybe a different faction, maybe give the Mechanical Marquise some abilities..?</p></content>
</entry>
<entry>
<title>Root Log for Feb. 27, 2021. Second game.</title>
<link href="https://drhayes.io/blog/root-log-2021-02-27-2/"/>
<updated>2021-02-22T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/root-log-2021-02-27-2/</id>
<content type="html"><h2>Overview</h2> <p>I am trying to document our Root games in a more regular, nerdy fashion so I can tighten up my thinking around the game itself and fine-tune my own strategies in general. We try to play at least once a week.</p> <p><a href="https://ledergames.com/products/root-a-game-of-woodland-might-and-right">Root</a> is my favorite board game in the world at the moment. It is hideously complex, and I've played more incorrect games than I have correct games, but we're getting there.</p> <h3>Game Setup</h3> <ul> <li>Factions <ul> <li>Me: Woodland Alliance</li> <li>Terra: Vagabond</li> <li>Alex: Underground Duchy</li> <li>Gabe: Corvid Conspiracy</li> </ul> </li> <li>Map: Starter</li> <li>Deck: Normal</li> </ul> <h3>Final State</h3> <ul> <li>Woodland won with 30 VP.</li> <li>Duchy went Bunny Dominance.</li> <li>The others were in the low 20s? It was late and I forgot to write things down during the game.</li> </ul> <h2>General Thoughts</h2> <p>Eyrie at one corner, Duchy at the other. In the early game, Corvids grouped kinda near the Duchy, Woodland grouped kinda near the Eyrie.</p> <p>Gabe's first try with the Corvids and he did well. We did an okay job smooshing his conspiracies, but his point total continued to increase throughout the game.</p> <p>Terra killed it in early- and mid-games, the almost-unstoppable juggernaut that we barely managed to stop at around somewhere around 24-26 VP. Her growth was driven by her choice of leader (extra point when removing tokens) and my insistence on being ground under her advance as the Woodland.</p> <p>At one point, Terra was one turn away from winning the game. She had a fox recruit in her decree, so killing her three (three!) fox roosts in a single turn kept us from getting completely killed. I killed a single warrior, leaving one roost undefended. Alex killed one roost. Gabe killed two, continuing the theme of Gabe saving our butts. That made her lose something like six points in turmoil and arrested her momentum.</p> <p>Alex went Bunny Dominance. Gabe and Terra worked really well to stop that from happening. I had a bunny base out at this point but didn't have enough officers to recruit to maintain rule there.</p> <p>The Woodland Alliance (me!) won at the end with an 11 VP gain through sympathy spread via supporters and Evening moves and organizes.</p> <h2>My Faction Performance</h2> <p>I love the Woodland Alliance so much. It was nice to return to them and play what I felt was a pretty good game.</p> <p>I had a slowdown right around when Terra was rushing toward victory. I knew I needed to stop granting her those 2 VP snacks on my sympathy, but couldn't spread away from her forces fast enough. When the effort came to stop her completely, I had a bunny base with three officers in the officers box. That let me do a move, a move, then an attack to remove a warrior and leave one fox roost defenseless. Gabe's Corvid came and cleaned that up, sending her into turmoil on her turn during recruit.</p> <p>At one point I had no sympathy on the board but a good supporters deck, something like two birds, two bunnies, and a couple of mice and/or foxes (can't remember). This was right around when Alex's Duchy was trying for bunny dominance.</p> <p>That let me put an initial sympathy in a different bunny clearing than my bunny base, spread out along the Eyrie's path to stop Alex's dominance run, and generate more supporters draw.</p> <p>The outrage drained Alex's bunny cards through Duchy movement, which was my contribution to stopping the Duchy win.</p> <p>Toward the end, I used Terra and Gabe's efforts to stop Alex's bunny dominance from ending the game to generate lots of supporters draw through outrage. The last 11 point push was (again) a pretty good supporters deck with around eight cards in it, and a final move and organize to put me over the top.</p> <p>I took too long to realize that Terra's Eyrie was pushing quickly toward the win on the back of removing my sympathy, even as I was in the second place for a long period in the early game because of the repeated sympathy placement. It almost cost the game.</p> <p>I think I re-organized well in the mid-game to recover from the total sympathy loss to get the win.</p> <p>I'm starting to think that nearly every faction in Root benefits or should plan on a cull in the mid-game to herald the start of end-game: Eyrie turmoils, Duchy swayed noble losses, Woodland Alliance sympathy and base losses, Marquise infrastructure stomping... It's going to happen, don't be afraid of it, just plan around it when it's looking likely.</p> <h2>Conclusions</h2> <p>I wasn't watching the other players enough. I didn't learn much about how Alex plays the Duchy or how Gabe plays the Corvids because I was so wrapped up in watching what Terra was doing with the Eyrie.</p> <p>In Alex's words, the Duchy might be out of his league. I know what he means. The last time I played them I played them like Marquise 2.0, which does them a disservice. I think he had some warrior overcommitment and lost his bunny cards from his hand, so no advantageous digging during dominance. That, plus some noble loss cost him his action economy late game.</p> <p>I didn't get to see what Gabe was doing, which stinks because he was keeping pace with everyone -- on his first time with the faction, no less. So... drat.</p> <p>I started closer to Terra and Gabe started closer to Alex, if those two space-warping factions could be said to be "close" to anyone. At the end of the game I had this idea that Gabe was more successful stopping Terra, while I was more successful stopping Alex. I don't think this is true now, after sleeping on it. I don't think I did much to the Duchy other than drain bunny cards -- it helped, sure, but wasn't a head-to-head confrontation. Which <em>is</em> the Woodland's style, in my experience, so, maybe, win? Hmm.</p> <h2>Next Time</h2> <p>Might be time to revisit the Cats so I can make them <em>really</em> distinct in my mind from the Moles. Could be time to try the Partisans deck. I could take another run at the Moles; if I do that, I need to emphasize their spatial weirdness instead of playing them like Cats++.</p></content>
</entry>
<entry>
<title>Wisps!</title>
<link href="https://drhayes.io/blog/wisps-new/"/>
<updated>2021-03-04T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/wisps-new/</id>
<content type="html"><p>I started building a <a href="https://wisps.drhayes.io/">weird microblogging thing I'm calling wisps</a>. I wanted a place to dump random linkspam, or post things that I thought were interesting, or whatever, but I didn't want or need a social network, a login, or another database somewhere with my personal info in it. Hence, I built my own. Coders gonna code, I guess.</p> <p>I always wanted to build a messy tumblelog in the "true" sense, something like <a href="https://leahneukirchen.org/anarchaia/">Anarchaia</a> but never quite got around to it. Now I have. It's powered entirely by Markdown on a filesystem.</p> <p>I think its form is going to stay pretty stripped down, for now: maybe an "about" page, maybe (maybe!) tags, and then... just keep dumping stuff on it.</p> <p>It currently handles only URLs, but I think the next thing is photos, maybe music (either Spotify or Soundcloud).</p> <p>The other fun part is the CLI helper I built for myself. Written in JS, it looks on my clipboard to see if there's a URL there and, if so, fetches it and pulls the title. Then it writes a Markdown doc in the right place on the filesystem with the right metadata leaving me a place to comment. I like painless and automated input systems.</p> <p>I'll open-source it eventually, nothing shameful in there (it's too simple for that) but I haven't decided if I want the wisps themselves to float along with the repo vs. what I do with <a href="https://notes.drhayes.io/">my notes site</a>, where the notes themselves are in a separate repo from the site that displays them. I don't think I'll end up going that route because the wisps, as suggested by the name, are very ephemeral things depicting what I was looking at that day. They aren't really a data source for mixing and matching like I want my notes to be.</p></content>
</entry>
<entry>
<title>Root Log for March 3, 2021.</title>
<link href="https://drhayes.io/blog/root-log-2021-03-07/"/>
<updated>2021-03-10T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/root-log-2021-03-07/</id>
<content type="html"><h2>Overview</h2> <p>I am trying to document our Root games in a more regular, nerdy fashion so I can tighten up my thinking around the game itself and fine-tune my own strategies in general. We try to play at least once a week.</p> <p><a href="https://ledergames.com/products/root-a-game-of-woodland-might-and-right">Root</a> is my favorite board game in the world at the moment. It is hideously complex, and I've played more incorrect games than I have correct games, but we're getting there.</p> <h3>Game Setup</h3> <ul> <li>Factions <ul> <li>Me: Lizard Cult</li> <li>Terra: Eyrie Cult</li> <li>Alex: Riverfolk Company</li> <li>Gabe: Corvid Conspiracy</li> <li>Lauren: Marquise de Cat</li> </ul> </li> <li>Map: Starter</li> <li>Deck: Normal</li> </ul> <h3>Final State</h3> <ul> <li>Riverfolk won with 30 VP.</li> <li>Eyrie went into turmoil twice.</li> </ul> <h2>General Thoughts</h2> <p>My heart wasn't quite in it tonight! I had a lot of fun socializing, but wasn't being careful in what I did and what targets I went after. This is the last time I try the "put myself under the Eyrie's foot and get stepped on for acolytes" strategy; it doesn't generate enough action economy vs. the resource loss of missing warriors to defend those gardens that I can stand up with my newfound acolytes.</p> <p>Alex loved the Otters, as we knew he would. Savvy play, an early funds lead before the table cut him off, and some good protectionism late game ("awful nice clearing you have here") got him the win.</p> <p>Terra had a great bird round as well. She wasn't getting lucky on card draws but was the other force to be reckoned with at the table.</p> <p>Gabe continued to threaten with the Corvids, lots of good plot placement and scoring -- I think he and Terra would have been contending for the lead if Alex hadn't pulled off a couple of monster turns midgame (7 points in turn 5!).</p> <p>Lauren was playing the Cats for the first time and did pretty well, especially against people who've played the game more and had more experience with their factions.</p> <p>I came in last. ðŸ¥‰ But I had a good time proving to myself that I love the Cult and can't sustainably play the RNG too much against people who know what they're doing.</p> <h2>My Faction Performance</h2> <p>I was never a real threat to anyone during the game. I insisted on mostly generating acolytes through battle loss instead of maintaining a warrior presence on the board to see how far I could push it. Turns out: not that far.</p> <p>I didn't score enough, holding on to those cards for "just one more recruit"... except the recruits weren't building toward any larger goal and thus weren't doing a lot of good versus, y'know, <em>actually getting points in the game</em>.</p> <p>I never built a solid defensive presence in my corner of the board nor established a strong offensive foothold with my gardens -- planning on making gardens only through acolytes is Bad Business.</p> <p>But I had fun seeing my friends and watching the play between the factions.</p> <h3>BAD ROOT PLAY ALERT</h3> <p>Lizards can have more than one garden in a clearing. Don't know why I thought they couldn't (except for the Eyrie's Roosts, and the Corvid's plot tokens, and and and). That changes things so much for my future strategies. Jesus.</p> <h2>Conclusions</h2> <p>The Lizard cult continues to be one of my favorites, despite everything. I don't feel like I've fully cracked them. Their RNG-ness is enticing and enforces one of the moral lessons of Root: "don't focus on any one thing too much".</p> <p><a href="https://rootgames.drhayes.io/rootgames">I'm working on a data explorer for our games here</a>. I kept per-turn scores this game but haven't updated the DB behind that site with the data yet. Soon, though.</p> <h2>Next Time</h2> <p>More Lizards. Moles still on the horizon.</p></content>
</entry>
<entry>
<title>Root Log for Mar. 14, 2021. First game.</title>
<link href="https://drhayes.io/blog/root-log-2021-03-14-1/"/>
<updated>2021-03-14T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/root-log-2021-03-14-1/</id>
<content type="html"><h2>Overview</h2> <p>I am trying to document our Root games in a more regular, nerdy fashion so I can tighten up my thinking around the game itself and fine-tune my own strategies in general. We try to play at least once a week.</p> <p><a href="https://ledergames.com/products/root-a-game-of-woodland-might-and-right">Root</a> is my favorite board game in the world at the moment. It is hideously complex, and I've played more incorrect games than I have correct games, but we're getting there.</p> <p>I wanted to try out this new Lizard Cult strategy. It worked and it didn't.</p> <p>First game with the Exiles and Partisans deck. It wasn't as impactful as we thought it would be... in a good way.</p> <h3>Game Setup</h3> <ul> <li>Factions <ul> <li>Me: Lizard Cult</li> <li>Terra: Underground Duchy</li> <li>Alex: Eyrie Dynasty</li> </ul> </li> <li>Map: Starter</li> <li>Deck: Exiles and Partisans</li> </ul> <h3>Final State</h3> <ul> <li>Terra won! First time with moles and she killed it.</li> <li>I don't think I broke 10 VP.</li> </ul> <h2>General Thoughts</h2> <p>Terra killed it. I think she might "get" the moles in a way that Alex and I just don't yet. Good for her! She did a good job balancing losing ministers (usually using higher-ranking ministers as a kind of shield for the ones below) against achieving what she wanted with regards to the map. She spread quickly, using tunnels to basically ignore the geometry of the map when she needed to. She got her action economy going at a great pace.</p> <p>Alex did his usual great job with the birds. He did the "recruit first turn then go into turmoil" thing, so had a bunch of warriors on the board to play with. When I tried that it tended to make me focus on moving warriors around and attacking instead of building infrastructure. He didn't spreading out and being a pain in the moles' backsides pretty early. I'll have to bug Alex about what he thinks went south for him in this game.</p> <p>I was on the other half of the board from those two and stayed out of their way for the most part. I was super conservative with my garden construction, focusing on getting 4 warriors in the clearing per garden before the garden was built. No one attacked me. I didn't craft anything. It was like I was playing the slow motion version of the game that was running on normal speed for the others.</p> <p>I don't think my clearings were attacked once.</p> <p>The Exiles and Partisans deck was not the game-upending thing we thought it would be. If anything, it seemed <em>incredibly</em> balanced. I think this was the game where Terra and I got the Saboteurs out early in case there were any shenanigans. That might've been the second game, though.</p> <p>The cards that I knew would really screw me didn't come in to play: Coffin Makers (no Acolytes for you!) and Swap Meet (I <em>really</em> care about what's in my hand).</p> <p>Playing Lizards in a three person game is... interesting. I wonder if there's not enough "action" from the other factions to get the Acolytes thing going, though I feel like I shouldn't need that to win.</p> <h2>My Faction Performance</h2> <p>My strategy was the 2x2 strategy from <a href="https://open.spotify.com/episode/2KMnrKsjAB3NQZUVXUD5ZY?si=lyFySp5RRAeP5yMCgrjEng">Space Cats Peace Turtles #165</a>: focus on getting into clearings with multiple building spaces and hole up, trying to get two gardens of two different suits as quickly as possible and start scoring. Focus on getting that card draw engine going.</p> <p>The thing where the Lizards start opposite the Eyrie sucks. On the Autumn map Alex tends to take the clearing with two building spaces in it <strong>cuz he's a punk</strong>. In this game, the opposite corner didn't line up too well with my hand; no bunny cards in my hand (the suit of my starting clearing), two birds, and a fox. Ugh. I eventually started getting mouse and fox cards and building up in the bottom clearings, but too slowly.</p> <p>I don't know that I crafted a single item. This is a weakness of mine as a Root player no matter what faction I play. By the time my faction got going the game was over.</p> <p>I didn't expand enough, a mistake given that my half of the board was empty relatively speaking.</p> <h2>Next Time</h2> <p><strong>MOAR LIZARDS</strong></p></content>
</entry>
<entry>
<title>Root Log for Mar. 14, 2021. Second game.</title>
<link href="https://drhayes.io/blog/root-log-2021-03-14-2/"/>
<updated>2021-03-14T00:00:00-00:00</updated>
<id>https://drhayes.io/blog/root-log-2021-03-14-2/</id>
<content type="html"><h2>Overview</h2> <p>I am trying to document our Root games in a more regular, nerdy fashion so I can tighten up my thinking around the game itself and fine-tune my own strategies in general. We try to play at least once a week.</p> <p><a href="https://ledergames.com/products/root-a-game-of-woodland-might-and-right">Root</a> is my favorite board game in the world at the moment. It is hideously complex, and I've played more incorrect games than I have correct games, but we're getting there.</p> <p>I wanted to try out this new Lizard Cult strategy. It worked better this time.</p> <h3>Game Setup</h3> <ul> <li>Factions <ul> <li>Me: Lizard Cult</li> <li>Terra: Underground Duchy</li> <li>Alex: Eyrie Dynasty</li> </ul> </li> <li>Map: Winter</li> <li>Deck: Exiles and Partisans</li> </ul> <h3>Final State</h3> <ul> <li>Terra won!</li> <li>This time she really had to work for it.</li> <li>Before going Dominance I'd barely cracked 11 VP. I almost won!</li> </ul> <h2>General Thoughts</h2> <p>Winter map! The RNG of the clearing suits gave us three adjacent fox clearings (ugh) which Alex grabbed (UGH).</p> <p>Terra did a great job again. I think we interfered with her stuff more often this time, but not nearly enough <em>again</em>. Letting her have buildings wherever makes it much, much harder to stop her... I mean, of course it does. But we didn't go after her enough. More on that later.</p> <p>Alex played the birds again, and was more aggressive about going after Terra's stuff in the beginning. After that she played the avoidance game pretty well and he had fewer opportunities to messs with her.</p> <p>I played... <em>better</em>, but not where I wanted to be with the lizards. I had a better starting hand, and the clearing suit RNG gave me two clearings matching my starting hand in that narrow spot in the winter map, kind of in the middle? That was great. Both those clearings have two building spots and I got four gardens up quicker than the last game. Not quick enough, but still.</p> <h2>My Faction Performance</h2> <p>Okay.</p> <p>Still running the <a href="https://open.spotify.com/episode/2KMnrKsjAB3NQZUVXUD5ZY?si=lyFySp5RRAeP5yMCgrjEng">2x2 strategy from Space Cats Peace Turtles</a>.</p> <p>I improved this game while still using the same strategy with some slack in a couple of places: I let myself build two gardens while only having six warriors in each clearing, I may have actually crafted at least one item (ugh). I branched out a bit into other clearings, but too late.</p> <p>One thing I really like about this strategy is how much it dismisses acolytes. I think our play group focuses on acolytes too much as the fearsome thing about the Lizards, especially because too many acolytes means a quick sanctify of your building and now I rule the clearing.</p> <p>I only did that a couple of times to prevent Terra's moles from kicking too much ass (good-bye, top-level Noble mole that generates VP per turn) and to interfere with Alex's decree (where you gonna recruit now?).</p> <p>I don't think either of my "main" two clearings were attacked once. Terra said "too intimidating", because they were swarming with lizards. I felt better about my scoring production this game, but it still wasn't good enough against the moles and birds, who were in a dead heat to 20 most of the game.</p> <p>And another thing: not sure how to stop another faction without losing my focus on my own point generation. Random recruits across the board to sow seeds for later? Actively look for opportunities to convert other warriors in other clearings to mess up the others?</p> <p>I wonder if the Lizards would work better in a five person game. There's a reason their reach is 2, after all. Or, maybe <em>I</em> work better in a five person game. I dunno.</p> <p>No one attacked my main clearings again this game... until I went Dominance! Even then it was my third, not nearly defended enough clearing, not my "main" two clearings I had throughout the early- and mid-game. I should use that more somehow.</p> <p>I got close with Dominance, but Terra pulled it off. Two in a row with a new faction! Good stuff.</p> <h2>Next Time</h2> <p><strong>I need to craft more</strong>. I want to write it on my hand for the next time we play.</p> <p>I think I might have moved Lizards once. That probably should happen more.</p> <p>How do the Lizards stop other factions who are racing to 20? It felt hard to score any single, decisive blow against the lead faction that was more than a stumbling block on their way to 20. Is that enough? I mean, too many stumbling blocks and they can't do it -- but the opportunity cost is my faction not recruiting or scoring or something, right? Is that worth it? If it costs the game, yes. But it's hard to look at a single incremental move and say "this is going to cost me the game" against the (more real, more immediate) "my garden isn't defended enough" threat.</p> <p>I think this is Root's main moral lesson coming back to haunt me: don't focus on one achievement that you've picked, <em>always</em> keep a tactical head on your shoulders and be on the lookout for good opportunities. That's one of the reasons I like the Lizards in the first place, because they exemplify it!</p> <p>I'm not done with the Lizards, not at all. I need to figure out this strategy's expansion story.</p></content>
</entry>
</feed> */
